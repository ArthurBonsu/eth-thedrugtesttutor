{"version":3,"sources":["webpack://Ganache/webpack/universalModuleDefinition","webpack://Ganache/webpack/bootstrap","webpack://Ganache/./lib/utils/to.js","webpack://Ganache/external \"util\"","webpack://Ganache/external \"async\"","webpack://Ganache/external \"ethereumjs-util\"","webpack://Ganache/external \"web3-provider-engine/subproviders/subprovider.js\"","webpack://Ganache/external \"bn.js\"","webpack://Ganache/external \"lodash\"","webpack://Ganache/external \"source-map-support/register\"","webpack://Ganache/external \"ethereumjs-account\"","webpack://Ganache/./lib/utils/runtimeerror.js","webpack://Ganache/./lib/utils/transaction.js","webpack://Ganache/external \"ethereumjs-block\"","webpack://Ganache/./lib/utils/log.js","webpack://Ganache/./lib/utils/receipt.js","webpack://Ganache/./lib/utils/errorhelper.js","webpack://Ganache/external \"events\"","webpack://Ganache/./node_modules/web3/src/index.js","webpack://Ganache/./lib/provider.js","webpack://Ganache/./node_modules/ethereumjs-wallet/index.js","webpack://Ganache/./lib/blockchain_double.js","webpack://Ganache/external \"merkle-patricia-tree\"","webpack://Ganache/external \"level-sublevel\"","webpack://Ganache/./lib/database/txserializer.js","webpack://Ganache/./lib/utils/txrejectederror.js","webpack://Ganache/./lib/utils/block_helper.js","webpack://Ganache/./public-exports.js","webpack://Ganache/external \"web3-provider-engine\"","webpack://Ganache/external \"web3-provider-engine/subproviders/subscriptions\"","webpack://Ganache/./lib/subproviders/requestfunnel.js","webpack://Ganache/./lib/subproviders/delayedblockfilter.js","webpack://Ganache/./lib/subproviders/gethdefaults.js","webpack://Ganache/./lib/subproviders/geth_api_double.js","webpack://Ganache/./lib/statemanager.js","webpack://Ganache/external \"ethereumjs-abi\"","webpack://Ganache/external \"ethereumjs-tx\"","webpack://Ganache/external \"ethereumjs-tx/fake\"","webpack://Ganache/external \"assert\"","webpack://Ganache/external \"rlp\"","webpack://Ganache/external \"seedrandom\"","webpack://Ganache/external \"bip39\"","webpack://Ganache/external \"safe-buffer\"","webpack://Ganache/external \"crypto\"","webpack://Ganache/external \"scrypt.js\"","webpack://Ganache/external \"uuid/v4\"","webpack://Ganache/external \"bs58check\"","webpack://Ganache/./node_modules/ethereumjs-wallet/hdkey.js","webpack://Ganache/external \"hdkey\"","webpack://Ganache/external \"ethereumjs-vm\"","webpack://Ganache/external \"heap\"","webpack://Ganache/./lib/database.js","webpack://Ganache/./lib/database/leveluparrayadapter.js","webpack://Ganache/./lib/database/levelupobjectadapter.js","webpack://Ganache/external \"levelup\"","webpack://Ganache/external \"encoding-down\"","webpack://Ganache/./lib/database/filedown.js","webpack://Ganache/external \"abstract-leveldown\"","webpack://Ganache/external \"fs\"","webpack://Ganache/external \"path\"","webpack://Ganache/external \"cachedown\"","webpack://Ganache/./lib/database/blockserializer.js","webpack://Ganache/./lib/database/bufferserializer.js","webpack://Ganache/./lib/database/blocklogsserializer.js","webpack://Ganache/./lib/database/receiptserializer.js","webpack://Ganache/external \"tmp\"","webpack://Ganache/./lib/utils/gasEstimation.js","webpack://Ganache/./lib/utils/forkedblockchain.js","webpack://Ganache/./lib/utils/forkedstoragetrie.js","webpack://Ganache/external \"merkle-patricia-tree/baseTrie\"","webpack://Ganache/external \"merkle-patricia-tree/checkpoint-interface\"","webpack://Ganache/external \"web3-core\"","webpack://Ganache/external \"web3-eth\"","webpack://Ganache/external \"web3-net\"","webpack://Ganache/external \"web3-eth-personal\"","webpack://Ganache/external \"web3-shh\"","webpack://Ganache/external \"web3-bzz\"","webpack://Ganache/external \"web3-utils\"","webpack://Ganache/external \"eth-sig-util\"","webpack://Ganache/./lib/utils/random.js","webpack://Ganache/./lib/block_tracker.js","webpack://Ganache/./lib/server.js","webpack://Ganache/./lib/webSocketServer.js","webpack://Ganache/external \"websocket\"","webpack://Ganache/./lib/httpServer.js","webpack://Ganache/external \"http\""],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","utils","buffer","val","data","indexOf","slice","length","Buffer","from","isBuffer","hex","trim","BN","intToHex","toString","addHexPrefix","_rpcQuantityHexString","this","replace","rpcQuantityHexString","rpcDataHexString","Array","fill","join","nullableRpcDataHexString","rpcDataHex","nullableRpcQuantityHexString","rpcQuantityHex","hexWithZeroPadding","digits","number","parseInt","bufVal","toBuffer","bufferToInt","rpcError","id","code","msg","JSON","stringify","jsonrpc","error","message","require","inherits","to","abi","RuntimeError","transactions","vmOutput","Error","captureStackTrace","constructor","results","hashes","combine","err","keys","push","apply","tx","result","vm","exception","reason","hash","returnData","return","rawDecode","exceptionError","program_counter","runState","programCounter","exceptionResult","count","fromResults","EthereumJsTransaction","EthereumJsFakeTransaction","ethUtil","assert","rlp","sign","fakeHash","_hash","arguments","BUFFER_ZERO","fixProps","_originals","forEach","fieldName","fieldLength","index","_fields","descriptor","getOwnPropertyDescriptor","set","v","configZeroableField","vDescriptors","sigV","chainId","Math","floor","_chainId","isFake","configurable","getSenderAddress","_from","Transaction","[object Object]","type","types","none","super","decode","self","isArray","field","raw","initData","signed","fake","json","toAccount","buf","equals","setLengthLeft","input","options","nonce","gasLimit","gas","gasPrice","_type","expectedNonce","isSigned","block","transactionIndex","txns","blockHash","blockNumber","header","includeSignature","items","cacheRaw","rlphash","Log","toJSON","logIndex","transactionHash","address","topics","Receipt","logs","gasUsed","cumulativeGasUsed","contractAddress","status","logsBloom","txHash","map","log","LevelUpOutOfRangeError","len","BlockOutOfRangeError","version","core","Eth","Net","Personal","Shh","Bzz","Web3","_this","packageInit","eth","shh","bzz","setProvider","provider","net","addProviders","ProviderEngine","SubscriptionSubprovider","RequestFunnel","DelayedBlockFilter","GethDefaults","GethApiDouble","BlockTracker","EventEmitter","_","Provider","_applyDefaultOptions","gethApiDouble","engine","blockTracker","blockchain","state","subscriptionSubprovider","manager","addProvider","setMaxListeners","start","sendAsync","send","close","_queueRequest","_processRequestQueue","on","notification","emit","defaultOptions","vmErrorsOnRPCResponse","verbose","asyncRequestProcessing","logger","merge","payload","callback","externalize","cloneDeep","intermediary","response","reportErrorInResponse","split","process","nextTick","stopMining","stop","_requestQueue","setImmediate","_requestInProgress","args","shift","cleanUpErrorObject","errorObject","stack","transactionMethods","_isTransactionRequest","request","method","_typeof","iterator","obj","crypto","scryptsy","uuidv4","bs58check","decipherBuffer","decipher","concat","update","final","Wallet","priv","pub","isValidPrivate","isValidPublic","_privKey","_pubKey","privateToPublic","privKey","generate","icapDirect","randomBytes","max","privateToAddress","lte","generateVanityAddress","pattern","RegExp","test","getPrivateKey","getPrivateKeyString","bufferToHex","getPublicKey","pubKey","getPublicKeyString","getAddress","publicToAddress","getAddressString","getChecksumAddressString","toChecksumAddress","toV3","password","opts","derivedKey","salt","iv","kdf","kdfparams","dklen","prf","pbkdf2Sync","cipher","createCipheriv","ciphertext","mac","sha3","random","uuid","cipherparams","getV3Filename","timestamp","Date","toV3String","fromPublicKey","nonStrict","importPublic","fromExtendedPublicKey","fromPrivateKey","fromExtendedPrivateKey","tmp","fromV1","parse","Version","Crypto","KeyHeader","Kdf","KdfParams","Salt","N","R","P","DkLen","CipherText","MAC","seed","createDecipheriv","IV","fromV3","toLowerCase","fromEthSale","encseed","wallet","ethaddr","Account","Block","VM","Trie","async","Heap","Database","estimateGas","promisify","BlockchainDouble","console","trie","db_path","pending_transactions","blockGasLimit","defaultTransactionGasLimit","timeAdjustment","time","debug","hardfork","allowUnlimitedContractSize","assign","initialize","accounts","latestBlock","stateRoot","stateTrie","createStateTrie","trie_db","createVMFromStateTrie","setTime","createGenesisBlock","stateManager","checkpoint","eachSeries","accountData","finished","putAccount","account","commit","putBlock","activatePrecompiles","getBlock","done","e","info","opcode","argsNum","in","arg","db","createBlock","blocks","last","getEffectiveBlockNumber","getHeight","blockHashes","blockIndex","first","receipts","requests","blockLogs","transactionReceipts","parallel","popBlock","del","pop","series","newLastBlock","setStateRoot","_storageTries","clearPendingTransactions","parent","getParent","parentNumber","currentTime","parentHash","getQueuedNonce","addressBuffer","pendingNonce","gt","iaddn","toArrayLike","queueTransaction","sortByPriceAndNonce","sortedByNonce","arr","nonceSort","a","b","sort","heap","sortedTransactions","size","best","processCall","runCall","parentBlock","newBlock","runArgs","skipBalance","skipNonce","runTx","vmerr","processBlock","runBlock","skipBlockValidation","totalBlockGasUsage","txTrie","rcptTrie","promises","putInTrie","put","receipt","txLogs","receiptLog","j","rcpt","createdAddress","bitvector","rawReceipt","rcptBuffer","encode","serialize","Promise","all","transactionsTrie","receiptTrie","processNextBlock","undefined","currentTransactions","totalGasLimit","maxGasLimit","processTransactionTrace","params","targetHash","txHashCurrentlyProcessing","txCurrentlyProcessing","storageStack","currentDepth","returnVal","returnValue","structLogs","stepListener","event","next","gasLeft","gasUsedThisStep","memory","disableMemory","match","lastItem","disableStack","item","structLog","depth","gasCost","op","pc","storage","disableStorage","processStorageTrace","getTransactionReceipt","targetBlock","forkBlockNumber","beforeTxListener","afterTxListener","removeListeners","removeListener","_cache","flush","cb","getContractStorage","getAccount","currentStateRoot","getNonce","getBalance","balance","getStorage","position","getCode","getTransaction","notFound","pendingTxs","getBlockLogs","effective","getTime","increaseTime","seconds","date","now","fromJSON","TXRejectedError","includeFullTransactions","mixHash","sha3Uncles","uncleHash","bloom","transactionsRoot","receiptsRoot","miner","coinbase","difficulty","totalDifficulty","extraData","toJsonRpc","uncles","Server","server","_webpacked","Subprovider","methods","eth_call","eth_getStorageAt","eth_sendTransaction","eth_sendRawTransaction","eth_newBlockFilter","eth_getFilterChanges","eth_getFilterLogs","queue","isWorking","handleRequest","end","external","processNext","watching","handleNewBlockFilter","handleGetFilterChanges","filterId","currentBlockHash","previousBlockHash","emitPayload","res","StateManager","blockHelper","pkg","initialized","initialization_error","post_initialization_callbacks","callbacks","waitForInitialization","addedBlockParam","requiresDefaultBlockParameter","minLength","errorMessage","getDelayedHandler","eth_getBalance","eth_getCode","eth_getTransactionCount","eth_estimateGas","eth_accounts","eth_blockNumber","eth_coinbase","eth_mining","is_mining","eth_hashrate","eth_gasPrice","eth_getBlockByNumber","eth_getBlockByHash","eth_getBlockTransactionCountByNumber","eth_getBlockTransactionCountByHash","eth_getTransactionReceipt","eth_getTransactionByHash","eth_getTransactionByBlockHashAndIndex","hashOrNumber","eth_getTransactionByBlockNumberAndIndex","getTransactionCount","eth_sign","dataToSign","eth_signTypedData","typedDataToSign","signTypedData","txData","rawTx","queueRawTransaction","queueStorage","latestFilterId","mine","eth_getLogs","filter","getLogs","eth_uninstallFilter","eth_protocolVersion","bzz_hive","bzz_info","shh_version","eth_getCompilers","eth_syncing","net_listening","net_peerCount","web3_clientVersion","web3_sha3","string","net_version","miner_start","threads","startMining","miner_stop","rpc_modules","rpc","web3","evm","personal","personal_listAccounts","personal_accounts","personal_newAccount","createAccount","account_passwords","personal_importRawKey","rawKey","secretKey","personal_lockAccount","unlocked_accounts","personal_unlockAccount","duration","storedPassword","personal_sendTransaction","ret","evm_snapshot","snapshot","evm_revert","snapshotId","revert","evm_increaseTime","evm_setTime","evm_mine","debug_traceTransaction","queueTransactionTrace","eth_getUncleCountByBlockHash","eth_getUncleCountByBlockNumber","eth_getUncleByBlockHashAndIndex","eth_getUncleByBlockNumberAndIndex","uncleIndex","eth_getWork","eth_submitWork","powHash","digest","eth_submitHashrate","hashRate","clientID","db_putString","dbName","db_getString","db_putHex","db_getHex","shh_post","priority","ttl","shh_newIdentity","shh_hasIdentity","shh_newGroup","shh_addToGroup","shh_newFilter","shh_uninstallFilter","shh_getFilterChanges","shh_getMessages","seedrandom","bip39","hdkey","ForkedBlockchain","sigUtil","ZERO_BUFFER","fork","secure","total_accounts","latest_filter_id","action_queue","action_processing","snapshots","network_id","mnemonic","fromMasterSeed","mnemonicToSeed","wallet_hdpath","hdPath","gasPriceVal","blockTime","is_mining_on_interval","mining_interval_timeout","_provider","default_balance_ether","randomAlphaNumericString","entropyToMnemonic","defaultBalanceWei","toWei","reduce","idx","forkVersion","mineOnInterval","_minerCancellationToken","clearTimeout","cancelled","cancellationToken","timeout","setTimeout","unref","derivePath","getWallet","publicKey","_queueTransaction","processNextAction","txJsonRpc","isKnownAccount","_setTransactionDefaults","allocUnsafe","override","queued","processTransaction","processGasEstimate","msgHash","hashPersonalMessage","sgn","ecsign","toRpcSig","EIP712Domain","domain","primaryType","printTransactionReceipt","runtimeError","finishedPrinting","processBlocks","totalBlocks","amountProcessed","whilst","createTransactionWithCorrectNonce","gasRefund","gasEstimate","add","expectedAddress","expectedTopics","fromBlock","toBlock","current","filtered","keep","expectedTopic","logTopic","isMatch","includes","nextSnapshot","during","doneWithTest","nextBlock","hasContractCode","getContractCode","isUnlocked","validateNonce","resolve","expected","actual","reject","then","catch","HDKey","EthereumHDKey","fromHDKey","_hdkey","seedBuffer","fromExtendedKey","base58key","privateExtendedKey","publicExtendedKey","path","derive","deriveChild","_privateKey","_publicKey","LevelUpArrayAdapter","LevelUpObjectAdapter","levelup","filedown","cachedown","txserializer","blockserializer","bufferserializer","BlockLogsSerializer","ReceiptSerializer","directory","finishInitializing","dir","getDir","levelupOptions","valueEncoding","store","maxSize","Sublevel","serializer","sublevel","_get","_put","encoded","RangeError","newLength","valueserializer","keyserializer","encodedKey","decodedValue","batch","array","each","isOpen","util","AbstractLevelDOWN","fs","FileDown","location","_open","writeFile","readFile","_del","unlink","_batch","txJson","database","steps","stepTracker","collect","opsLength","ops","success","lowestGasIndex","costOfData","acc","curr","total","getTotal","sysOpIndex","estimate","lastSVT","tailCost","sub","stipend","lt","sumRange","top","needed","tail","findParentScope","opIndex","findIndex","begin","systemOps","parentBegin","parentEnd","isStipend","lowestIndex","lowestGas","Infinity","findLowestIndex","rootBegin","rootEnd","findRootScope","systemOpSum","callingSysOp","callingFee","fee","sumOfCurrentSysOp","neededBefore6364","oneSixtyFloorth","prevParentBegin","prevParentEnd","costOfParentReturn","remaining","sysOps","allOps","svt","isCall","opname","isTerminator","indexMap","lowestSysOpIndex","lowestGasLeft","simpleCallCheck","simpleCallDepth","toNumber","isCreate","simpleValueTransfers","ForkedStorageTrie","fork_block_number","providers","HttpProvider","storageTrieCache","patchVM","getId","_trie","lookupAccount","getLookupAccount","_lookupAccount","_lookupStorageTrie","getLookupStorageTrie","storageTrie","copy","isFallbackBlock","isBlockHash","byteLength","isFallbackBlockHash","getFallbackBlock","numberOrHash","real","checkFn","isFallback","getRelativeBlockNumber","keyExists","exists","fetchCodeFromFallback","fetchAccountFromFallback","receiptJson","fetchBalanceFromFallback","fetchNonceFromFallback","setCode","getSafeFallbackBlockNumber","safeBlockNumber","toBN","relative","currentProvider","MerklePatriciaTree","BaseTrie","checkpointInterface","ForkedStorageBaseTrie","getStorageAt","findPath","node","remainder","prove","verifyProof","rng","alphabet","text","charAt","GanacheBlockTracker","_blockchain","getTrackingBlock","awaitCurrentBlock","_setCurrentBlock","_currentBlock","getCurrentBlock","once","_isRunning","oldBlock","webSocketServer","httpServer","keepAliveTimeout","connectionCounter","connections","conn","oldListen","listen","ws","oldClose","destroy","websocket","WebSocketServer","ConnectionManager","connectionsBySubscriptionId","_updateSubscriptions","manageConnection","_logPayload","_handleRequest","connectionManager","wsServer","autoAcceptConnections","connection","subscriptions","utf8Data","binaryData","CLOSE_REASON_UNPROCESSABLE_INPUT","subscriptionId","subscription","http","sendResponse","statusCode","headers","writeHead","createServer","body","chunk","requestHeaders","origin","createCORSResponseHeaders","ganacheProvider"],"mappings":"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","file":"ganache.core.node.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Ganache\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Ganache\"] = factory();\n\telse\n\t\troot[\"Ganache\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 25);\n","let utils = require(\"ethereumjs-util\");\n\nmodule.exports = {\n  buffer: function(val) {\n    let data;\n    if (typeof val === \"string\") {\n      // strings need to be treated as hex, so we have to prep them:\n      data = val.indexOf(\"0x\") === 0 ? val.slice(2) : val;\n      data = data.length % 2 === 1 ? `0${data}` : data;\n      data = Buffer.from(data, \"hex\");\n    } else if (Buffer.isBuffer(val)) {\n      // no need to copy the Buffer to a new Buffer, so we just use the Buffer\n      // exactly as it was given to us:\n      data = val;\n    } else {\n      // all other types get the Buffer treatment and built-in type checking:\n      data = Buffer.from(val);\n    }\n    return data;\n  },\n  // Note: Do not use to.hex() when you really mean utils.addHexPrefix().\n  hex: function(val) {\n    if (typeof val === \"string\") {\n      if (val.indexOf(\"0x\") === 0) {\n        return val.trim();\n      } else {\n        val = new utils.BN(val);\n      }\n    }\n\n    if (typeof val === \"boolean\") {\n      val = val ? 1 : 0;\n    }\n\n    if (typeof val === \"number\") {\n      val = utils.intToHex(val);\n    } else if (val == null) {\n      return \"0x\";\n    } else if (typeof val === \"object\") {\n      // Support Buffer, BigInteger and BN library\n      // Hint: BN is used in ethereumjs\n      val = val.toString(\"hex\");\n    }\n\n    return utils.addHexPrefix(val);\n  },\n\n  _rpcQuantityHexString: function(val) {\n    val = this.hex(val);\n    // remove all zeroes leading zeros, `0+`, from the hex-encoded value\n    // This doesn't remove the last 0 which would be captured by `(.+?)`\n    val = val.replace(/^(?:0x)(?:0+(.+?))?$/, \"0x$1\");\n    return val;\n  },\n\n  rpcQuantityHexString: function(val) {\n    val = this._rpcQuantityHexString(val);\n\n    // RPC Quantities must represent `0` as `0x0`\n    if (val === \"0x\") {\n      val = \"0x0\";\n    }\n\n    return val;\n  },\n\n  rpcDataHexString: function(val, length) {\n    if (typeof length === \"number\") {\n      val = this.hex(val).replace(\"0x\", \"\");\n\n      val = new Array(length - val.length).fill(\"0\").join(\"\") + val;\n    } else {\n      if (val.length === 0) {\n        return \"0x\";\n      }\n      val = this.hex(val).replace(\"0x\", \"\");\n\n      if (val.length % 2 !== 0) {\n        val = \"0\" + val;\n      }\n    }\n    return \"0x\" + val;\n  },\n\n  nullableRpcDataHexString: function(val, length) {\n    if (val === null) {\n      return null;\n    } else {\n      const rpcDataHex = this.rpcDataHexString(val, length);\n      return rpcDataHex === \"0x\" ? null : rpcDataHex;\n    }\n  },\n\n  nullableRpcQuantityHexString: function(val, length) {\n    if (val === null) {\n      return null;\n    } else {\n      const rpcQuantityHex = this._rpcQuantityHexString(val, length);\n      return rpcQuantityHex === \"0x\" ? null : rpcQuantityHex;\n    }\n  },\n\n  hexWithZeroPadding: function(val) {\n    val = this.hex(val);\n    const digits = val.replace(\"0x\", \"\");\n    if (digits.length & 0x1) {\n      return \"0x0\" + digits;\n    }\n    return val;\n  },\n\n  number: function(val) {\n    if (typeof val === \"number\") {\n      return val;\n    }\n    if (typeof val === \"string\") {\n      if (val.indexOf(\"0x\") !== 0) {\n        return parseInt(val, 10);\n      }\n    }\n    var bufVal = utils.toBuffer(val);\n    return utils.bufferToInt(bufVal);\n  },\n\n  rpcError: function(id, code, msg) {\n    return JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: id,\n      error: {\n        code: code,\n        message: msg\n      }\n    });\n  }\n};\n","module.exports = require(\"util\");","module.exports = require(\"async\");","module.exports = require(\"ethereumjs-util\");","module.exports = require(\"web3-provider-engine/subproviders/subprovider.js\");","module.exports = require(\"bn.js\");","module.exports = require(\"lodash\");","module.exports = require(\"source-map-support/register\");","module.exports = require(\"ethereumjs-account\");","var inherits = require(\"util\").inherits;\nvar to = require(\"./to\");\nvar abi = require(\"ethereumjs-abi\");\n\ninherits(RuntimeError, Error);\n\n// Note: ethereumjs-vm will return an object that has a \"results\" and \"receipts\" keys.\n// You should pass in the whole object.\nfunction RuntimeError(transactions, vmOutput) {\n  // Why not just Error.apply(this, [message])? See\n  // https://gist.github.com/justmoon/15511f92e5216fa2624b#anti-patterns\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n\n  this.results = {};\n  this.hashes = [];\n\n  // handles creating this.message\n  this.combine(transactions, vmOutput);\n}\n\nRuntimeError.prototype.combine = function(transactions, vmOutput) {\n  // Can be combined with vmOutput or another RuntimeError.\n  if (transactions instanceof RuntimeError) {\n    var err = transactions;\n    var keys = Object.keys(err.results);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      this.results[key] = err.results[key];\n      Array.prototype.push.apply(this.hashes, err.hashes);\n    }\n  } else {\n    var results = vmOutput.results;\n\n    for (i = 0; i < transactions.length; i++) {\n      var tx = transactions[i];\n      var result = results[i];\n\n      // 1 means no error, oddly.\n      if (result.vm.exception !== 1) {\n        var hash = to.hex(tx.hash());\n        this.hashes.push(hash);\n        var reason;\n        var returnData = result.vm.return;\n        if (returnData && returnData.slice(0, 4).toString(\"hex\") === \"08c379a0\") {\n          reason = abi.rawDecode([\"string\"], returnData.slice(4))[0];\n        }\n\n        this.results[hash] = {\n          error: result.vm.exceptionError.error || result.vm.exceptionError,\n          program_counter: result.vm.runState.programCounter,\n          return: to.hex(result.vm.return),\n          reason: reason\n        };\n      }\n    }\n  }\n\n  // Once combined, set the message\n  if (this.hashes.length === 1) {\n    var exceptionResult = this.results[this.hashes[0]];\n    var message = \"VM Exception while processing transaction: \" + exceptionResult.error;\n    if (exceptionResult.reason) {\n      message += \" \" + exceptionResult.reason;\n    }\n    this.message = message;\n  } else {\n    message = \"Multiple VM Exceptions while processing transactions: \\n\\n\";\n\n    for (i = 0; i < this.hashes.length; i++) {\n      hash = this.hashes[i];\n      exceptionResult = this.results[hash];\n      message += hash + \": \" + exceptionResult.error;\n      if (exceptionResult.reason) {\n        message += \" \" + exceptionResult.reason;\n      }\n      message += \"\\n\";\n    }\n    this.message = message;\n  }\n};\n\nRuntimeError.prototype.count = function() {\n  return Object.keys(this.results).length;\n};\n\nRuntimeError.fromResults = function(transactions, vmOutput) {\n  var err = new RuntimeError(transactions, vmOutput);\n\n  if (err.count() === 0) {\n    return null;\n  }\n\n  return err;\n};\n\nmodule.exports = RuntimeError;\n","const EthereumJsTransaction = require(\"ethereumjs-tx\");\nconst EthereumJsFakeTransaction = require(\"ethereumjs-tx/fake\");\nconst ethUtil = require(\"ethereumjs-util\");\nconst assert = require(\"assert\");\nconst rlp = require(\"rlp\");\nconst to = require(\"./to\");\n\nconst sign = EthereumJsTransaction.prototype.sign;\nconst fakeHash = function() {\n  // this isn't memoization of the hash. previous versions of ganache-core\n  // created hashes in a different/incorrect way and are recorded this way\n  // in snapshot dbs. We are preserving the chain's immutability by using the\n  // stored hash instead of calculating it.\n  if (this._hash != null) {\n    return this._hash;\n  }\n  return EthereumJsFakeTransaction.prototype.hash.apply(this, arguments);\n};\nconst BUFFER_ZERO = Buffer.from([0]);\n\nfunction configZeroableField(tx, fieldName, fieldLength = 32) {\n  const index = tx._fields.indexOf(fieldName);\n  const descriptor = Object.getOwnPropertyDescriptor(tx, fieldName);\n  // eslint-disable-next-line accessor-pairs\n  Object.defineProperty(tx, fieldName, {\n    set: (v) => {\n      descriptor.set.call(tx, v);\n      v = ethUtil.toBuffer(v);\n      assert(fieldLength >= v.length, `The field ${fieldName} must not have more ${fieldLength} bytes`);\n      tx._originals[index] = v;\n    },\n    get: () => {\n      return tx._originals[index];\n    }\n  });\n}\n\n/**\n * etheruemjs-tx's Transactions don't behave quite like we need them to, so\n * we're monkey-patching them to do what we want here.\n * @param {Transaction} tx The Transaction to fix\n * @param {Object} [data] The data object\n */\nfunction fixProps(tx, data) {\n  // ethereumjs-tx doesn't allow for a `0` value in fields, but we want it to\n  // in order to differentiate between a value that isn't set and a value\n  // that is set to 0 in a fake transaction.\n  // Once https://github.com/ethereumjs/ethereumjs-tx/issues/112 is figured\n  // out we can probably remove this fix/hack.\n  // We keep track of the original value and return that value when\n  // referenced by its property name. This lets us properly encode a `0` as\n  // an empty buffer while still being able to differentiate between a `0`\n  // and `null`/`undefined`.\n  tx._originals = [];\n  const fieldNames = [\"nonce\", \"gasPrice\", \"gasLimit\", \"value\"];\n  fieldNames.forEach((fieldName) => configZeroableField(tx, fieldName, 32));\n\n  // Ethereumjs-tx doesn't set the _chainId value whenever the v value is set,\n  // which causes transaction signing to fail on transactions that include a\n  // chain id in the v value (like ethers.js does).\n  // Whenever the v value changes we need to make sure the chainId is also set.\n  const vDescriptors = Object.getOwnPropertyDescriptor(tx, \"v\");\n  // eslint-disable-next-line accessor-pairs\n  Object.defineProperty(tx, \"v\", {\n    set: (v) => {\n      vDescriptors.set.call(tx, v);\n      // calculate chainId from signature\n      const sigV = ethUtil.bufferToInt(tx.v);\n      let chainId = Math.floor((sigV - 35) / 2);\n      if (chainId < 0) {\n        chainId = 0;\n      }\n      tx._chainId = chainId || 0;\n    }\n  });\n\n  if (tx.isFake()) {\n    /**\n     * @prop {Buffer} from (read/write) Set from address to bypass transaction\n     * signing on fake transactions.\n     */\n    Object.defineProperty(tx, \"from\", {\n      enumerable: true,\n      configurable: true,\n      get: tx.getSenderAddress.bind(tx),\n      set: (val) => {\n        if (val) {\n          tx._from = ethUtil.toBuffer(val);\n        } else {\n          tx._from = null;\n        }\n      }\n    });\n\n    if (data && data.from) {\n      tx.from = data.from;\n    }\n\n    tx.hash = fakeHash;\n  }\n}\n\n/**\n * Parses the given data object and adds its properties to the given tx.\n * @param {Transaction} tx\n * @param {Object} [data]\n */\nfunction initData(tx, data) {\n  if (data) {\n    if (typeof data === \"string\") {\n      data = to.buffer(data);\n    }\n    if (Buffer.isBuffer(data)) {\n      data = rlp.decode(data);\n    }\n    const self = tx;\n    if (Array.isArray(data)) {\n      if (data.length > tx._fields.length) {\n        throw new Error(\"wrong number of fields in data\");\n      }\n\n      // make sure all the items are buffers\n      data.forEach((d, i) => {\n        self[self._fields[i]] = ethUtil.toBuffer(d);\n      });\n    } else if ((typeof data === \"undefined\" ? \"undefined\" : typeof data) === \"object\") {\n      const keys = Object.keys(data);\n      tx._fields.forEach(function(field) {\n        if (keys.indexOf(field) !== -1) {\n          self[field] = data[field];\n        }\n        if (field === \"gasLimit\") {\n          if (keys.indexOf(\"gas\") !== -1) {\n            self[\"gas\"] = data[\"gas\"];\n          }\n        } else if (field === \"data\") {\n          if (keys.indexOf(\"input\") !== -1) {\n            self[\"input\"] = data[\"input\"];\n          }\n        }\n      });\n\n      // Set chainId value from the data, if it's there and the data didn't\n      // contain a `v` value with chainId in it already. If we do have a\n      // data.chainId value let's set the interval v value to it.\n      if (!tx._chainId && data && data.chainId != null) {\n        tx.raw[self._fields.indexOf(\"v\")] = tx._chainId = data.chainId || 0;\n      }\n    } else {\n      throw new Error(\"invalid data\");\n    }\n  }\n}\n\nmodule.exports = class Transaction extends EthereumJsTransaction {\n  /**\n   * @param {Object} [data] The data for this Transaction.\n   * @param {Number} type The `Transaction.types` bit flag for this transaction\n   *  Can be a combination of `Transaction.types.none`, `Transaction.types.signed`, and `Transaction.types.fake`.\n   */\n  constructor(data, type = Transaction.types.none) {\n    super();\n\n    this.type = type;\n\n    fixProps(this, data);\n    initData(this, data);\n  }\n\n  static get types() {\n    // values must be powers of 2\n    return {\n      none: 0,\n      signed: 1,\n      fake: 2\n    };\n  }\n\n  /**\n   * Prepares arbitrary JSON data for use in a Transaction.\n   * @param {Object} json JSON object representing the Transaction\n   * @param {Number} type The `Transaction.types` bit flag for this transaction\n   *  Can be a combination of `Transaction.types.none`, `Transaction.types.signed`, and `Transaction.types.fake`.\n   */\n  static fromJSON(json, type) {\n    let toAccount;\n    if (json.to) {\n      // Remove all padding and make it easily comparible.\n      const buf = to.buffer(json.to);\n      if (buf.equals(Buffer.from([0]))) {\n        // if the address is 0x0 make it 0x0{20}\n        toAccount = ethUtil.setLengthLeft(buf, 20);\n      } else {\n        toAccount = buf;\n      }\n    }\n    const data = json.data || json.input;\n    const options = {\n      nonce: ethUtil.toBuffer(to.hex(json.nonce)),\n      from: ethUtil.toBuffer(to.hex(json.from)),\n      value: ethUtil.toBuffer(to.hex(json.value)),\n      gasLimit: ethUtil.toBuffer(to.hex(json.gas || json.gasLimit)),\n      gasPrice: ethUtil.toBuffer(to.hex(json.gasPrice)),\n      data: data ? to.buffer(data) : null,\n      to: toAccount,\n      v: ethUtil.toBuffer(json.v),\n      r: ethUtil.toBuffer(json.r),\n      s: ethUtil.toBuffer(json.s)\n    };\n\n    const tx = new Transaction(options, type);\n    tx._hash = json.hash ? to.buffer(json.hash) : null;\n    return tx;\n  }\n\n  /**\n   * Encodes the Transaction in order to be used in a database. Can be decoded\n   * into an identical Transaction via `Transaction.decode(encodedTx)`.\n   */\n  encode() {\n    const resultJSON = {\n      hash: to.nullableRpcDataHexString(this.hash()),\n      nonce: to.nullableRpcQuantityHexString(this.nonce) || \"0x\",\n      from: to.rpcDataHexString(this.from),\n      to: to.nullableRpcDataHexString(this.to),\n      value: to.nullableRpcQuantityHexString(this.value),\n      gas: to.nullableRpcQuantityHexString(this.gasLimit),\n      gasPrice: to.nullableRpcQuantityHexString(this.gasPrice),\n      data: this.data ? this.data.toString(\"hex\") : null,\n      v: to.nullableRpcQuantityHexString(this.v),\n      r: to.nullableRpcDataHexString(this.r),\n      s: to.nullableRpcDataHexString(this.s),\n      _type: this.type\n    };\n    return resultJSON;\n  }\n\n  isFake() {\n    return (this.type & Transaction.types.fake) === Transaction.types.fake;\n  }\n\n  isSigned() {\n    return (this.type & Transaction.types.signed) === Transaction.types.signed;\n  }\n\n  /**\n   * Compares the transaction's nonce value to the given expectedNonce taking in\n   * to account the type of transaction and comparison rules for each type.\n   *\n   * In a signed transaction a nonce of Buffer([]) is the same as Buffer([0]),\n   * but in a fake transaction Buffer([]) is null and Buffer([0]) is 0.\n   *\n   * @param {Buffer} expectedNonce The value of the from account's next nonce.\n   */\n  validateNonce(expectedNonce) {\n    let nonce;\n    if (this.isSigned() && this.nonce.length === 0) {\n      nonce = BUFFER_ZERO;\n    } else {\n      nonce = this.nonce;\n    }\n    return nonce.equals(expectedNonce);\n  }\n\n  /**\n   * Signs the transaction and sets the `type` bit for `signed` to 1,\n   * i.e., `isSigned() === true`\n   */\n  sign() {\n    sign.apply(this, arguments);\n    this.type |= Transaction.types.signed;\n  }\n\n  /**\n   * Returns a JSON-RPC spec compliant representation of this Transaction.\n   *\n   * @param {Object} block The block this Transaction appears in.\n   */\n  toJsonRpc(block) {\n    const hash = this.hash();\n\n    let transactionIndex = null;\n    for (let i = 0, txns = block.transactions, l = txns.length; i < l; i++) {\n      if (txns[i].hash().equals(hash)) {\n        transactionIndex = i;\n        break;\n      }\n    }\n\n    const resultJSON = {\n      hash: to.nullableRpcDataHexString(hash),\n      nonce: to.rpcQuantityHexString(this.nonce),\n      blockHash: to.nullableRpcDataHexString(block.hash()),\n      blockNumber: to.nullableRpcQuantityHexString(block.header.number),\n      transactionIndex: to.nullableRpcQuantityHexString(transactionIndex),\n      from: to.rpcDataHexString(this.from),\n      to: to.nullableRpcDataHexString(this.to),\n      value: to.rpcQuantityHexString(this.value),\n      gas: to.rpcQuantityHexString(this.gasLimit),\n      gasPrice: to.rpcQuantityHexString(this.gasPrice),\n      input: to.rpcDataHexString(this.data),\n      v: to.nullableRpcQuantityHexString(this.v),\n      r: to.nullableRpcDataHexString(this.r),\n      s: to.nullableRpcDataHexString(this.s)\n    };\n\n    return resultJSON;\n  }\n\n  /**\n   * Computes a sha3-256 hash of the serialized tx\n   *\n   * This method is nearly identical to ethereumjs-tx hash with the exception of\n   * the v,r,s value setting when _chainId > 0. Because the `_chainId` in our\n   * implementation is calculated whenever the v is updated we have to make sure\n   * we don't recalc the chainId when we set the v to soemthing else.\n   *\n   * Note: If the transaction is a fake transaction this hash method gets\n   * overridden in the constructor.\n   *\n   * @param {Boolean} [includeSignature=true] whether or not to inculde the signature\n   * @return {Buffer}\n   */\n  hash(includeSignature = true) {\n    // EIP155 spec:\n    // when computing the hash of a transaction for purposes of signing or recovering,\n    // instead of hashing only the first six elements (ie. nonce, gasprice, startgas, to, value, data),\n    // hash nine elements, with v replaced by CHAIN_ID, r = 0 and s = 0\n\n    let items;\n    if (includeSignature) {\n      items = this.raw;\n    } else {\n      // cache the chainId here\n      const chainId = this._chainId;\n      if (chainId > 0) {\n        const cacheRaw = this.raw.slice();\n        // Setting `this.v` changes the value of `this._chainId`\n        this.v = chainId;\n        this.r = 0;\n        this.s = 0;\n\n        items = this.raw;\n        this.raw = cacheRaw;\n        // set the chainId back to its original value here.\n        this._chainId = chainId;\n      } else {\n        items = this.raw.slice(0, 6);\n      }\n    }\n\n    // create hash\n    return ethUtil.rlphash(items);\n  }\n};\n","module.exports = require(\"ethereumjs-block\");","var to = require(\"./to.js\");\n\n// Expects:\n//\n// logIndex: ...\n// transactionIndex: ...\n// transactionHash: ...\n// block: ...\n// address: ...\n// data: ...\n// topics: ...\n// type: ...\n\nfunction Log(data) {\n  var self = this;\n  Object.keys(data).forEach(function(key) {\n    self[key] = data[key];\n  });\n}\n\nLog.prototype.toJSON = function() {\n  // RPC quantity values like this.transactionIndex can be set to \"0x00\",\n  // use the explicit rpcQuantityHexString to properly format the JSON, removing leading zeroes.\n  // See RPC log format spec: https://github.com/ethereum/wiki/wiki/JSON-RPC\n  return {\n    logIndex: to.rpcQuantityHexString(this.logIndex),\n    transactionIndex: to.rpcQuantityHexString(this.transactionIndex),\n    transactionHash: to.rpcDataHexString(this.transactionHash),\n    blockHash: to.rpcDataHexString(this.block.hash()),\n    blockNumber: to.rpcQuantityHexString(this.block.header.number),\n    address: to.rpcDataHexString(this.address),\n    data: to.rpcDataHexString(this.data),\n    topics: this.topics,\n    type: \"mined\"\n  };\n};\n\nmodule.exports = Log;\n","var to = require(\"./to\");\n\nfunction Receipt(tx, block, logs, gasUsed, cumulativeGasUsed, contractAddress, status, logsBloom) {\n  this.tx = tx;\n  this.block = block;\n  this.logs = logs;\n  this.gasUsed = gasUsed;\n  this.cumulativeGasUsed = cumulativeGasUsed;\n  this.contractAddress = contractAddress;\n  this.status = status;\n  this.logsBloom = logsBloom;\n\n  this.transactionIndex = 0;\n\n  this.txHash = tx.hash();\n\n  for (var i = 0; i < block.transactions.length; i++) {\n    var current = block.transactions[i];\n    if (current.hash().equals(this.txHash)) {\n      this.transactionIndex = i;\n      break;\n    }\n  }\n}\n\nReceipt.prototype.toJSON = function() {\n  // Enforce Hex formatting as defined in the RPC spec.\n  return {\n    transactionHash: to.rpcDataHexString(this.txHash),\n    transactionIndex: to.rpcQuantityHexString(this.transactionIndex),\n    blockHash: to.rpcDataHexString(this.block.hash()),\n    blockNumber: to.rpcQuantityHexString(this.block.header.number),\n    from: to.rpcDataHexString(this.tx.from),\n    to: to.nullableRpcDataHexString(this.tx.to),\n    gasUsed: to.rpcQuantityHexString(this.gasUsed),\n    cumulativeGasUsed: to.rpcQuantityHexString(this.cumulativeGasUsed),\n    contractAddress: this.contractAddress != null ? to.rpcDataHexString(this.contractAddress) : null,\n    logs: this.logs.map(function(log) {\n      return log.toJSON();\n    }),\n    status: to.rpcQuantityHexString(this.status),\n    logsBloom: to.rpcDataHexString(this.logsBloom),\n    v: to.rpcDataHexString(this.tx.v),\n    r: to.rpcDataHexString(this.tx.r),\n    s: to.rpcDataHexString(this.tx.s)\n  };\n};\n\nmodule.exports = Receipt;\n","class LevelUpOutOfRangeError extends Error {\n  constructor(type, index, len) {\n    const message = \"LevelUpArrayAdapter named '\" + type + \"' index out of range: index \" + index + \"; length: \" + len;\n    super(message);\n    this.name = `${this.constructor.name}:${type}`;\n    this.type = type;\n  }\n}\n\nclass BlockOutOfRangeError extends LevelUpOutOfRangeError {\n  constructor(index, len) {\n    super(\"blocks\", index, len);\n  }\n}\n\nmodule.exports = {\n  LevelUpOutOfRangeError,\n  BlockOutOfRangeError\n};\n","module.exports = require(\"events\");","/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @authors:\n *   Fabian Vogelsteller <fabian@ethereum.org>\n *   Gav Wood <gav@parity.io>\n *   Jeffrey Wilcke <jeffrey.wilcke@ethereum.org>\n *   Marek Kotewicz <marek@parity.io>\n *   Marian Oancea <marian@ethereum.org>\n * @date 2017\n */\n\n\"use strict\";\n\n\nvar version = require('../package.json').version;\nvar core = require('web3-core');\nvar Eth = require('web3-eth');\nvar Net = require('web3-net');\nvar Personal = require('web3-eth-personal');\nvar Shh = require('web3-shh');\nvar Bzz = require('web3-bzz');\nvar utils = require('web3-utils');\n\nvar Web3 = function Web3() {\n    var _this = this;\n\n    // sets _requestmanager etc\n    core.packageInit(this, arguments);\n\n    this.version = version;\n    this.utils = utils;\n\n    this.eth = new Eth(this);\n    this.shh = new Shh(this);\n    this.bzz = new Bzz(this);\n\n    // overwrite package setProvider\n    var setProvider = this.setProvider;\n    this.setProvider = function (provider, net) {\n        setProvider.apply(_this, arguments);\n\n        this.eth.setProvider(provider, net);\n        this.shh.setProvider(provider, net);\n        this.bzz.setProvider(provider);\n\n        return true;\n    };\n};\n\nWeb3.version = version;\nWeb3.utils = utils;\nWeb3.modules = {\n    Eth: Eth,\n    Net: Net,\n    Personal: Personal,\n    Shh: Shh,\n    Bzz: Bzz\n};\n\ncore.addProviders(Web3);\n\nmodule.exports = Web3;\n\n","// make sourcemaps work!\nrequire(\"source-map-support/register\");\n\nlet ProviderEngine = require(\"web3-provider-engine\");\nlet SubscriptionSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\n\nlet RequestFunnel = require(\"./subproviders/requestfunnel\");\nlet DelayedBlockFilter = require(\"./subproviders/delayedblockfilter\");\nlet GethDefaults = require(\"./subproviders/gethdefaults\");\nlet GethApiDouble = require(\"./subproviders/geth_api_double\");\n\nlet BlockTracker = require(\"./block_tracker\");\n\nlet RuntimeError = require(\"./utils/runtimeerror\");\nlet EventEmitter = require(\"events\");\n\nlet _ = require(\"lodash\");\n\nfunction Provider(options) {\n  const self = this;\n  EventEmitter.call(this);\n\n  this.options = options = self._applyDefaultOptions(options || {});\n\n  let gethApiDouble = new GethApiDouble(options, this);\n\n  this.engine = new ProviderEngine({\n    blockTracker: new BlockTracker({ blockchain: gethApiDouble.state.blockchain })\n  });\n\n  let subscriptionSubprovider = new SubscriptionSubprovider();\n\n  this.engine.manager = gethApiDouble;\n  this.engine.addProvider(new RequestFunnel());\n  this.engine.addProvider(new DelayedBlockFilter());\n  this.engine.addProvider(subscriptionSubprovider);\n  this.engine.addProvider(new GethDefaults());\n  this.engine.addProvider(gethApiDouble);\n\n  this.engine.setMaxListeners(100);\n  this.engine.start();\n\n  this.manager = gethApiDouble;\n  this.sendAsync = this.send.bind(this);\n  this.send = this.send.bind(this);\n  this.close = this.close.bind(this);\n  this._queueRequest = this._queueRequest.bind(this);\n  this._processRequestQueue = this._processRequestQueue.bind(this);\n\n  subscriptionSubprovider.on(\"data\", function(err, notification) {\n    self.emit(\"data\", err, notification);\n  });\n}\n\nconst defaultOptions = {\n  vmErrorsOnRPCResponse: true,\n  verbose: false,\n  asyncRequestProcessing: false,\n  logger: {\n    log: function() {}\n  }\n};\n\nProvider.prototype = Object.create(EventEmitter.prototype);\nProvider.prototype.constructor = Provider;\n\nProvider.prototype._applyDefaultOptions = function(options) {\n  return _.merge({}, defaultOptions, options);\n};\n\nProvider.prototype.send = function(payload, callback) {\n  if (typeof callback !== \"function\") {\n    throw new Error(\n      \"No callback provided to provider's send function. As of web3 1.0, provider.send \" +\n        \"is no longer synchronous and must be passed a callback as its final argument.\"\n    );\n  }\n\n  let self = this;\n\n  let externalize = function(payload) {\n    return _.cloneDeep(payload);\n  };\n\n  if (Array.isArray(payload)) {\n    payload = payload.map(externalize);\n  } else {\n    payload = externalize(payload);\n  }\n\n  let intermediary = function(err, result) {\n    // clone result so that we can mutate the response without worrying about\n    // that messing up assumptions the calling logic might have about us\n    // mutating things\n    result = _.cloneDeep(result);\n    let response;\n    if (Array.isArray(result)) {\n      response = [];\n      for (let i = 0; i < result.length; i++) {\n        response.push(self.reportErrorInResponse(payload[i], err, result[i]));\n      }\n    } else {\n      response = self.reportErrorInResponse(payload, err, result);\n    }\n\n    if (self.options.verbose) {\n      self.options.logger.log(\n        \" <   \" +\n          JSON.stringify(response, null, 2)\n            .split(\"\\n\")\n            .join(\"\\n <   \")\n      );\n    }\n    process.nextTick(() => callback(response.error ? err : null, response));\n  };\n\n  if (self.options.verbose) {\n    self.options.logger.log(\n      \"   > \" +\n        JSON.stringify(payload, null, 2)\n          .split(\"\\n\")\n          .join(\"\\n   > \")\n    );\n  }\n\n  if (self.options.asyncRequestProcessing) {\n    self.engine.sendAsync(payload, intermediary);\n  } else {\n    self._queueRequest(payload, intermediary);\n  }\n};\n\nProvider.prototype.close = function(callback) {\n  // This is a little gross reaching, but...\n  this.manager.state.stopMining();\n  this.manager.state.blockchain.close(callback);\n  this.engine.stop();\n};\n\nProvider.prototype._queueRequest = function(payload, intermediary) {\n  if (!this._requestQueue) {\n    this._requestQueue = [];\n  }\n\n  this._requestQueue.push({\n    payload: payload,\n    callback: intermediary\n  });\n\n  setImmediate(this._processRequestQueue);\n};\n\nProvider.prototype._processRequestQueue = function() {\n  const self = this;\n\n  if (self._requestInProgress) {\n    return;\n  }\n\n  self._requestInProgress = true;\n\n  let args = self._requestQueue.shift();\n\n  if (args) {\n    self.engine.sendAsync(args.payload, (err, result) => {\n      if (self._requestQueue.length > 0) {\n        setImmediate(self._processRequestQueue);\n      }\n      args.callback(err, result);\n      self._requestInProgress = false;\n    });\n  } else {\n    // still need to free the lock\n    self._requestInProgress = false;\n\n    if (self._requestQueue.length > 0) {\n      setImmediate(self._processRequestQueue);\n    }\n  }\n};\n\nProvider.prototype.cleanUpErrorObject = function(err, response) {\n  // Our response should already have an error field at this point, if it\n  // doesn't, this was likely intentional. If not, this is the wrong place to\n  // fix that problem.\n  if (!err || !response.error) {\n    return response;\n  }\n\n  let errorObject = {\n    error: {\n      data: {}\n    }\n  };\n\n  if (err.message) {\n    // clean up the error reporting done by the provider engine so the error message isn't lost in the stack trace noise\n    errorObject.error.message = err.message;\n    errorObject.error.data.stack = err.stack;\n    errorObject.error.data.name = err.name;\n  } else if (!response.error) {\n    errorObject.error = {\n      message: err.toString()\n    };\n  }\n\n  return _.merge(response, errorObject);\n};\n\n// helper list of RPC methods which execute code and respond with a transaction hash as their result\nlet transactionMethods = [\"eth_sendTransaction\", \"eth_sendRawTransaction\", \"personal_sendTransaction\"];\n\nProvider.prototype._isTransactionRequest = function(request) {\n  return transactionMethods.indexOf(request.method) !== -1;\n};\n\nProvider.prototype.reportErrorInResponse = function(request, err, response) {\n  const self = this;\n\n  if (!err) {\n    return response;\n  }\n\n  // TODO: for next major release: move reporting of tx hash on error to error\n  // field to prevent poorly-written clients which assume that the existence of\n  // the \"result\" field implies no errors from breaking.\n  if (self._isTransactionRequest(request)) {\n    if (err instanceof RuntimeError) {\n      // Make sure we always return the transaction hash on failed transactions so\n      // the caller can get their tx receipt. This breaks JSONRPC 2.0, but it's how\n      // we've always done it.\n      response.result = err.hashes[0];\n\n      if (self.options.vmErrorsOnRPCResponse) {\n        if (!response.error.data) {\n          response.error.data = {};\n        }\n        response.error.data[err.hashes[0]] = err.results[err.hashes[0]];\n      } else {\n        delete response.error;\n      }\n    }\n  }\n\n  if (request.method === \"eth_call\") {\n    if (err instanceof RuntimeError) {\n      if (self.options.vmErrorsOnRPCResponse) {\n        if (!response.error.data) {\n          response.error.data = {};\n        }\n        response.error.data[err.hashes[0]] = err.results[err.hashes[0]];\n      } else {\n        response.result = err.results[err.hashes[0]].return || \"0x\";\n        delete response.error;\n      }\n    }\n  }\n\n  return self.cleanUpErrorObject(err, response);\n};\n\nmodule.exports = Provider;\n","'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar Buffer = require('safe-buffer').Buffer;\nvar ethUtil = require('ethereumjs-util');\nvar crypto = require('crypto');\nvar scryptsy = require('scrypt.js');\nvar uuidv4 = require('uuid/v4');\nvar bs58check = require('bs58check');\n\nfunction assert(val, msg) {\n  if (!val) {\n    throw new Error(msg || 'Assertion failed');\n  }\n}\n\nfunction decipherBuffer(decipher, data) {\n  return Buffer.concat([decipher.update(data), decipher.final()]);\n}\n\nvar Wallet = function Wallet(priv, pub) {\n  if (priv && pub) {\n    throw new Error('Cannot supply both a private and a public key to the constructor');\n  }\n\n  if (priv && !ethUtil.isValidPrivate(priv)) {\n    throw new Error('Private key does not satisfy the curve requirements (ie. it is invalid)');\n  }\n\n  if (pub && !ethUtil.isValidPublic(pub)) {\n    throw new Error('Invalid public key');\n  }\n\n  this._privKey = priv;\n  this._pubKey = pub;\n};\n\nObject.defineProperty(Wallet.prototype, 'privKey', {\n  get: function get() {\n    assert(this._privKey, 'This is a public key only wallet');\n    return this._privKey;\n  }\n});\n\nObject.defineProperty(Wallet.prototype, 'pubKey', {\n  get: function get() {\n    if (!this._pubKey) {\n      this._pubKey = ethUtil.privateToPublic(this.privKey);\n    }\n    return this._pubKey;\n  }\n});\n\nWallet.generate = function (icapDirect) {\n  if (icapDirect) {\n    var max = new ethUtil.BN('088f924eeceeda7fe92e1f5b0fffffffffffffff', 16);\n    while (true) {\n      var privKey = crypto.randomBytes(32);\n      if (new ethUtil.BN(ethUtil.privateToAddress(privKey)).lte(max)) {\n        return new Wallet(privKey);\n      }\n    }\n  } else {\n    return new Wallet(crypto.randomBytes(32));\n  }\n};\n\nWallet.generateVanityAddress = function (pattern) {\n  if ((typeof pattern === 'undefined' ? 'undefined' : _typeof(pattern)) !== 'object') {\n    pattern = new RegExp(pattern);\n  }\n\n  while (true) {\n    var privKey = crypto.randomBytes(32);\n    var address = ethUtil.privateToAddress(privKey);\n\n    if (pattern.test(address.toString('hex'))) {\n      return new Wallet(privKey);\n    }\n  }\n};\n\nWallet.prototype.getPrivateKey = function () {\n  return this.privKey;\n};\n\nWallet.prototype.getPrivateKeyString = function () {\n  return ethUtil.bufferToHex(this.getPrivateKey());\n};\n\nWallet.prototype.getPublicKey = function () {\n  return this.pubKey;\n};\n\nWallet.prototype.getPublicKeyString = function () {\n  return ethUtil.bufferToHex(this.getPublicKey());\n};\n\nWallet.prototype.getAddress = function () {\n  return ethUtil.publicToAddress(this.pubKey);\n};\n\nWallet.prototype.getAddressString = function () {\n  return ethUtil.bufferToHex(this.getAddress());\n};\n\nWallet.prototype.getChecksumAddressString = function () {\n  return ethUtil.toChecksumAddress(this.getAddressString());\n};\n\n// https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\nWallet.prototype.toV3 = function (password, opts) {\n  assert(this._privKey, 'This is a public key only wallet');\n\n  opts = opts || {};\n  var salt = opts.salt || crypto.randomBytes(32);\n  var iv = opts.iv || crypto.randomBytes(16);\n\n  var derivedKey;\n  var kdf = opts.kdf || 'scrypt';\n  var kdfparams = {\n    dklen: opts.dklen || 32,\n    salt: salt.toString('hex')\n  };\n\n  if (kdf === 'pbkdf2') {\n    kdfparams.c = opts.c || 262144;\n    kdfparams.prf = 'hmac-sha256';\n    derivedKey = crypto.pbkdf2Sync(Buffer.from(password), salt, kdfparams.c, kdfparams.dklen, 'sha256');\n  } else if (kdf === 'scrypt') {\n    // FIXME: support progress reporting callback\n    kdfparams.n = opts.n || 262144;\n    kdfparams.r = opts.r || 8;\n    kdfparams.p = opts.p || 1;\n    derivedKey = scryptsy(Buffer.from(password), salt, kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n  } else {\n    throw new Error('Unsupported kdf');\n  }\n\n  var cipher = crypto.createCipheriv(opts.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n  if (!cipher) {\n    throw new Error('Unsupported cipher');\n  }\n\n  var ciphertext = Buffer.concat([cipher.update(this.privKey), cipher.final()]);\n\n  var mac = ethUtil.sha3(Buffer.concat([derivedKey.slice(16, 32), Buffer.from(ciphertext, 'hex')]));\n\n  return {\n    version: 3,\n    id: uuidv4({ random: opts.uuid || crypto.randomBytes(16) }),\n    address: this.getAddress().toString('hex'),\n    crypto: {\n      ciphertext: ciphertext.toString('hex'),\n      cipherparams: {\n        iv: iv.toString('hex')\n      },\n      cipher: opts.cipher || 'aes-128-ctr',\n      kdf: kdf,\n      kdfparams: kdfparams,\n      mac: mac.toString('hex')\n    }\n  };\n};\n\nWallet.prototype.getV3Filename = function (timestamp) {\n  /*\n   * We want a timestamp like 2016-03-15T17-11-33.007598288Z. Date formatting\n   * is a pain in Javascript, everbody knows that. We could use moment.js,\n   * but decide to do it manually in order to save space.\n   *\n   * toJSON() returns a pretty close version, so let's use it. It is not UTC though,\n   * but does it really matter?\n   *\n   * Alternative manual way with padding and Date fields: http://stackoverflow.com/a/7244288/4964819\n   *\n   */\n  var ts = timestamp ? new Date(timestamp) : new Date();\n\n  return ['UTC--', ts.toJSON().replace(/:/g, '-'), '--', this.getAddress().toString('hex')].join('');\n};\n\nWallet.prototype.toV3String = function (password, opts) {\n  return JSON.stringify(this.toV3(password, opts));\n};\n\nWallet.fromPublicKey = function (pub, nonStrict) {\n  if (nonStrict) {\n    pub = ethUtil.importPublic(pub);\n  }\n  return new Wallet(null, pub);\n};\n\nWallet.fromExtendedPublicKey = function (pub) {\n  assert(pub.slice(0, 4) === 'xpub', 'Not an extended public key');\n  pub = bs58check.decode(pub).slice(45);\n  // Convert to an Ethereum public key\n  return Wallet.fromPublicKey(pub, true);\n};\n\nWallet.fromPrivateKey = function (priv) {\n  return new Wallet(priv);\n};\n\nWallet.fromExtendedPrivateKey = function (priv) {\n  assert(priv.slice(0, 4) === 'xprv', 'Not an extended private key');\n  var tmp = bs58check.decode(priv);\n  assert(tmp[45] === 0, 'Invalid extended private key');\n  return Wallet.fromPrivateKey(tmp.slice(46));\n};\n\n// https://github.com/ethereum/go-ethereum/wiki/Passphrase-protected-key-store-spec\nWallet.fromV1 = function (input, password) {\n  assert(typeof password === 'string');\n  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);\n\n  if (json.Version !== '1') {\n    throw new Error('Not a V1 wallet');\n  }\n\n  if (json.Crypto.KeyHeader.Kdf !== 'scrypt') {\n    throw new Error('Unsupported key derivation scheme');\n  }\n\n  var kdfparams = json.Crypto.KeyHeader.KdfParams;\n  var derivedKey = scryptsy(Buffer.from(password), Buffer.from(json.Crypto.Salt, 'hex'), kdfparams.N, kdfparams.R, kdfparams.P, kdfparams.DkLen);\n\n  var ciphertext = Buffer.from(json.Crypto.CipherText, 'hex');\n\n  var mac = ethUtil.sha3(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));\n\n  if (mac.toString('hex') !== json.Crypto.MAC) {\n    throw new Error('Key derivation failed - possibly wrong passphrase');\n  }\n\n  var decipher = crypto.createDecipheriv('aes-128-cbc', ethUtil.sha3(derivedKey.slice(0, 16)).slice(0, 16), Buffer.from(json.Crypto.IV, 'hex'));\n  var seed = decipherBuffer(decipher, ciphertext);\n\n  return new Wallet(seed);\n};\n\nWallet.fromV3 = function (input, password, nonStrict) {\n  assert(typeof password === 'string');\n  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(nonStrict ? input.toLowerCase() : input);\n\n  if (json.version !== 3) {\n    throw new Error('Not a V3 wallet');\n  }\n\n  var derivedKey;\n  var kdfparams;\n  if (json.crypto.kdf === 'scrypt') {\n    kdfparams = json.crypto.kdfparams;\n\n    // FIXME: support progress reporting callback\n    derivedKey = scryptsy(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n  } else if (json.crypto.kdf === 'pbkdf2') {\n    kdfparams = json.crypto.kdfparams;\n\n    if (kdfparams.prf !== 'hmac-sha256') {\n      throw new Error('Unsupported parameters to PBKDF2');\n    }\n\n    derivedKey = crypto.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n  } else {\n    throw new Error('Unsupported key derivation scheme');\n  }\n\n  var ciphertext = Buffer.from(json.crypto.ciphertext, 'hex');\n\n  var mac = ethUtil.sha3(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));\n  if (mac.toString('hex') !== json.crypto.mac) {\n    throw new Error('Key derivation failed - possibly wrong passphrase');\n  }\n\n  var decipher = crypto.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, 'hex'));\n  var seed = decipherBuffer(decipher, ciphertext, 'hex');\n\n  return new Wallet(seed);\n};\n\n/*\n * Based on https://github.com/ethereum/pyethsaletool/blob/master/pyethsaletool.py\n * JSON fields: encseed, ethaddr, btcaddr, email\n */\nWallet.fromEthSale = function (input, password) {\n  assert(typeof password === 'string');\n  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);\n\n  var encseed = Buffer.from(json.encseed, 'hex');\n\n  // key derivation\n  var derivedKey = crypto.pbkdf2Sync(password, password, 2000, 32, 'sha256').slice(0, 16);\n\n  // seed decoding (IV is first 16 bytes)\n  // NOTE: crypto (derived from openssl) when used with aes-*-cbc will handle PKCS#7 padding internally\n  //       see also http://stackoverflow.com/a/31614770/4964819\n  var decipher = crypto.createDecipheriv('aes-128-cbc', derivedKey, encseed.slice(0, 16));\n  var seed = decipherBuffer(decipher, encseed.slice(16));\n\n  var wallet = new Wallet(ethUtil.sha3(seed));\n  if (wallet.getAddress().toString('hex') !== json.ethaddr) {\n    throw new Error('Decoded key mismatch - possibly wrong passphrase');\n  }\n  return wallet;\n};\n\nmodule.exports = Wallet;","var to = require(\"./utils/to.js\");\nvar Account = require(\"ethereumjs-account\");\nvar Block = require(\"ethereumjs-block\");\nvar Log = require(\"./utils/log\");\nvar Receipt = require(\"./utils/receipt\");\nvar VM = require(\"ethereumjs-vm\");\nvar RuntimeError = require(\"./utils/runtimeerror\");\nvar Trie = require(\"merkle-patricia-tree\");\nvar utils = require(\"ethereumjs-util\");\nvar async = require(\"async\");\nvar Heap = require(\"heap\");\nvar Database = require(\"./database\");\nvar EventEmitter = require(\"events\");\nvar estimateGas = require(\"./utils/gasEstimation\");\nvar _ = require(\"lodash\");\nvar promisify = require(\"util\").promisify;\nconst BN = require(\"bn.js\");\n\nfunction BlockchainDouble(options) {\n  var self = this;\n  EventEmitter.apply(self);\n\n  this.options = options = this._applyDefaultOptions(options || {});\n\n  this.logger = options.logger || console;\n\n  this.data = new Database(options);\n\n  if (options.trie != null && options.db_path != null) {\n    throw new Error(\"Can't initialize a TestRPC with a db and a custom trie.\");\n  }\n\n  this.pending_transactions = [];\n\n  // updated periodically to keep up with the times\n  this.blockGasLimit = options.gasLimit;\n  this.defaultTransactionGasLimit = options.defaultTransactionGasLimit;\n  this.timeAdjustment = 0;\n}\n\nconst defaultOptions = {\n  gasLimit: \"0x6691b7\",\n  defaultTransactionGasLimit: \"0x15f90\",\n  time: null,\n  debug: false,\n  hardfork: \"petersburg\",\n  allowUnlimitedContractSize: false\n};\n\n// inheritence w/ prototype chaining\nBlockchainDouble.prototype = Object.create(EventEmitter.prototype);\nBlockchainDouble.prototype.constructor = BlockchainDouble;\n\nBlockchainDouble.prototype._applyDefaultOptions = function(options) {\n  // We want this function to mutate the options object so that we can report\n  // our settings back to our consumer application (e.g., ganache)\n  return _.merge(options, defaultOptions, Object.assign({}, options));\n};\n\nBlockchainDouble.prototype.initialize = function(accounts, callback) {\n  var self = this;\n\n  this.data.initialize(function(err) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.latestBlock(function(err, block) {\n      if (err) {\n        return callback(err);\n      }\n\n      var options = self.options;\n\n      var root = null;\n\n      if (block) {\n        root = block.header.stateRoot;\n      }\n\n      // I haven't yet found a good way to do this. Getting the trie from the\n      // forked blockchain without going through the other setup is a little gross.\n      self.stateTrie = self.createStateTrie(self.data.trie_db, root);\n\n      self.vm = options.vm || self.createVMFromStateTrie(self.stateTrie, true);\n\n      if (options.time) {\n        self.setTime(options.time);\n      }\n\n      // If we already have a block, then that means there's an existing chain.\n      // Don't create a genesis block.\n      if (block) {\n        self.emit(\"block\", block);\n        return callback();\n      }\n\n      self.createGenesisBlock(function(err, block) {\n        if (err) {\n          return callback(err);\n        }\n\n        accounts = accounts || [];\n\n        self.vm.stateManager.checkpoint(() => {\n          async.eachSeries(\n            accounts,\n            function(accountData, finished) {\n              self.vm.stateManager.putAccount(utils.toBuffer(accountData.address), accountData.account, finished);\n            },\n            function(err) {\n              if (err) {\n                return callback(err);\n              }\n\n              self.vm.stateManager.commit(() => {\n                // Create first block\n                self.putBlock(block, [], [], callback);\n              });\n            }\n          );\n        });\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.createVMFromStateTrie = function(state, activatePrecompiles) {\n  const self = this;\n  const vm = new VM({\n    state: state,\n    blockchain: {\n      // EthereumJS VM needs a blockchain object in order to get block information.\n      // When calling getBlock() it will pass a number that's of a Buffer type.\n      // Unfortunately, it uses a 64-character buffer (when converted to hex) to\n      // represent block numbers as well as block hashes. Since it's very unlikely\n      // any block number will get higher than the maximum safe Javascript integer,\n      // we can convert this buffer to a number ahead of time before calling our\n      // own getBlock(). If the conversion succeeds, we have a block number.\n      // If it doesn't, we have a block hash. (Note: Our implementation accepts both.)\n      getBlock: function(number, done) {\n        try {\n          number = to.number(number);\n        } catch (e) {\n          // Do nothing; must be a block hash.\n        }\n\n        self.getBlock(number, done);\n      }\n    },\n    activatePrecompiles: activatePrecompiles || false,\n    hardfork: self.options.hardfork,\n    allowUnlimitedContractSize: self.options.allowUnlimitedContractSize\n  });\n\n  if (self.options.debug === true) {\n    // log executed opcodes, including args as hex\n    vm.on(\"step\", function(info) {\n      var name = info.opcode.name;\n      var argsNum = info.opcode.in;\n      if (argsNum) {\n        var args = info.stack\n          .slice(-argsNum)\n          .map((arg) => to.hex(arg))\n          .join(\" \");\n\n        self.logger.log(`${name} ${args}`);\n      } else {\n        self.logger.log(name);\n      }\n    });\n  }\n\n  return vm;\n};\n\nBlockchainDouble.prototype.createStateTrie = function(db, root) {\n  return new Trie(db, root);\n};\n\n// Overrideable so other implementations (forking) can edit it.\nBlockchainDouble.prototype.createGenesisBlock = function(callback) {\n  this.createBlock(callback);\n};\n\nBlockchainDouble.prototype.latestBlock = function(callback) {\n  this.data.blocks.last(function(err, last) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, last);\n  });\n};\n\n// number accepts number (integer, hex) or tag (e.g., \"latest\")\nBlockchainDouble.prototype.getEffectiveBlockNumber = function(number, callback) {\n  if (typeof number !== \"string\") {\n    number = to.hex(number);\n  }\n\n  // If we have a hex number\n  if (number.indexOf(\"0x\") >= 0) {\n    return callback(null, to.number(number));\n  } else {\n    if (number === \"latest\" || number === \"pending\") {\n      return this.getHeight(callback);\n    } else if (number === \"earliest\") {\n      return callback(null, 0);\n    }\n  }\n};\n\n// number accepts number (integer, hex), tag (e.g., \"latest\") or block hash\n// This function is used by ethereumjs-vm\nBlockchainDouble.prototype.getBlock = function(number, callback) {\n  var self = this;\n\n  if (typeof number !== \"string\") {\n    number = to.hex(number);\n  }\n\n  // If we have a hex number or a block hash\n  if (number.indexOf(\"0x\") >= 0) {\n    var hash = number;\n\n    // block hash\n    if (hash.length > 40) {\n      this.data.blockHashes.get(to.hex(hash), function(err, blockIndex) {\n        if (err) {\n          return callback(err);\n        }\n        return self.data.blocks.get(blockIndex, callback);\n      });\n    } else {\n      // Block number\n      return this.data.blocks.get(to.number(hash), callback);\n    }\n  } else {\n    if (number === \"latest\" || number === \"pending\") {\n      return this.latestBlock(callback);\n    } else if (number === \"earliest\") {\n      return this.data.blocks.first(callback);\n    } else {\n      process.nextTick(callback, new Error(\"Invalid `blockNumber`: \\\"\" + number + \"\\\"\"));\n    }\n  }\n};\n\nBlockchainDouble.prototype.putBlock = function(block, logs, receipts, callback) {\n  var self = this;\n\n  // Lock in the state root for this block.\n  block.header.stateRoot = this.stateTrie.root;\n\n  this.data.blocks.length(function(err, length) {\n    if (err) {\n      return callback(err);\n    }\n\n    var requests = [\n      self.data.blocks.push.bind(self.data.blocks, block),\n      self.data.blockLogs.push.bind(self.data.blockLogs, logs),\n      self.data.blockHashes.set.bind(self.data.blockHashes, to.hex(block.hash()), length)\n    ];\n\n    block.transactions.forEach(function(tx, index) {\n      var txHash = to.hex(tx.hash());\n      requests.push(\n        self.data.transactions.set.bind(self.data.transactions, txHash, tx),\n        self.data.transactionReceipts.set.bind(self.data.transactionReceipts, txHash, receipts[index])\n      );\n    });\n\n    async.parallel(requests, (err, result) => {\n      if (!err) {\n        self.emit(\"block\", block);\n      }\n      callback(err, result);\n    });\n  });\n};\n\nBlockchainDouble.prototype.popBlock = function(callback) {\n  var self = this;\n\n  this.data.blocks.last(function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n    if (block == null) {\n      return callback(null, null);\n    }\n\n    var requests = [];\n    var blockHash = to.hex(block.hash());\n\n    block.transactions.forEach(function(tx) {\n      var txHash = to.hex(tx.hash());\n\n      requests.push(\n        self.data.transactions.del.bind(self.data.transactions, txHash),\n        self.data.transactionReceipts.del.bind(self.data.transactionReceipts, txHash)\n      );\n    });\n\n    requests.push(\n      self.data.blockLogs.pop.bind(self.data.blockLogs),\n      self.data.blockHashes.del.bind(self.data.blockHashes, blockHash),\n      self.data.blocks.pop.bind(self.data.blocks) // Do this one last in case anything relies on it.\n    );\n\n    async.series(requests, function(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      // Set the root to the last available, which will \"roll back\" to the previous\n      // moment in time. Note that all the old data is still in the db, but it's now just junk data.\n      self.data.blocks.last(function(err, newLastBlock) {\n        if (err) {\n          return callback(err);\n        }\n        // using setStateRoot because in the future it will automatically take care\n        // of clearing the cache for us.\n        // note setStateRoot checks for checkpoints, and if there are any, it will fail.\n        // At time of writing this comment, the only time there could be a checkpoint\n        // is in the middle of a vm.runBlock call. Once asyncRequestProcessing is reenabled\n        // this will likely cause problems.\n        self.vm.stateManager.setStateRoot(newLastBlock.header.stateRoot, function(err) {\n          // remove this `._storageTries = {}` statement once https://github.com/ethereumjs/ethereumjs-vm/pull/445\n          // is in a release, probably in ejs-vm 2.6.1\n          if (!err) {\n            self.vm.stateManager._storageTries = {};\n          }\n          // Remember: Return block we popped off.\n          callback(err, block);\n        });\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.clearPendingTransactions = function() {\n  this.pending_transactions = [];\n};\n\n/**\n * createBlock\n *\n * Create a new block, where the parent's block is either the latest block\n * on the chain or the parent block passed in.\n *\n * @param  {Block}   parent   The block meant to be the parent block (optional)\n * @param  {Function} callback Callback function called after block is created\n * @return Block              The block created.\n */\nBlockchainDouble.prototype.createBlock = function(parent, callback) {\n  var self = this;\n\n  if (typeof parent === \"function\") {\n    callback = parent;\n    parent = null;\n  }\n\n  var block = new Block();\n\n  function getParent(callback) {\n    if (parent) {\n      return callback(null, parent);\n    } else {\n      self.latestBlock(callback);\n    }\n  }\n\n  getParent(function(err, parent) {\n    if (err) {\n      return callback(err);\n    }\n\n    var parentNumber = parent != null ? to.number(parent.header.number) : -1;\n\n    block.header.gasLimit = self.blockGasLimit;\n\n    // Ensure we have the right block number for the VM.\n    block.header.number = to.hex(parentNumber + 1);\n\n    // Set the timestamp before processing txs\n    block.header.timestamp = to.hex(self.currentTime());\n\n    if (parent != null) {\n      block.header.parentHash = to.hex(parent.hash());\n    }\n\n    callback(null, block);\n  });\n};\n\nBlockchainDouble.prototype.getQueuedNonce = function(address, callback) {\n  var nonce = null;\n  var addressBuffer = to.buffer(address);\n  this.pending_transactions.forEach(function(tx) {\n    if (!tx.from.equals(addressBuffer)) {\n      return;\n    }\n\n    var pendingNonce = new BN(tx.nonce);\n    // If this is the first queued nonce for this address we found,\n    // or it's higher than the previous highest, note it.\n    if (nonce === null || pendingNonce.gt(nonce)) {\n      nonce = pendingNonce;\n    }\n  });\n\n  // If we found a queued transaction nonce, return one higher\n  // than the highest we found\n  if (nonce != null) {\n    return callback(null, nonce.iaddn(1).toArrayLike(Buffer));\n  }\n  this.stateTrie.get(addressBuffer, function(err, val) {\n    if (err) {\n      return callback(err);\n    }\n\n    var account = new Account(val);\n    // nonces are initiallized as an empty buffer, which isn't what we want.\n    callback(null, account.nonce.length === 0 ? Buffer.from([0]) : account.nonce);\n  });\n};\n\nBlockchainDouble.prototype.queueTransaction = function(tx) {\n  this.pending_transactions.push(tx);\n};\n\nBlockchainDouble.prototype.sortByPriceAndNonce = function() {\n  // Sorts transactions like I believe geth does.\n  // See the description of 'SortByPriceAndNonce' at\n  // https://github.com/ethereum/go-ethereum/blob/290e851f57f5d27a1d5f0f7ad784c836e017c337/core/types/transaction.go\n  var self = this;\n  var sortedByNonce = {};\n\n  self.pending_transactions.forEach((tx) => {\n    const from = tx.from.toString(\"hex\");\n    const arr = sortedByNonce[from];\n    if (arr) {\n      arr.push(tx);\n    } else {\n      sortedByNonce[from] = [tx];\n    }\n  });\n\n  var priceSort = function(a, b) {\n    return parseInt(to.hex(b.gasPrice), 16) - parseInt(to.hex(a.gasPrice), 16);\n  };\n  var nonceSort = function(a, b) {\n    return parseInt(to.hex(a.nonce), 16) - parseInt(to.hex(b.nonce), 16);\n  };\n\n  // Now sort each address by nonce\n  Object.keys(sortedByNonce).forEach((address) => {\n    sortedByNonce[address].sort(nonceSort);\n  });\n\n  // Initialise a heap, sorted by price, for the head transaction from each account.\n  var heap = new Heap(priceSort);\n  Object.keys(sortedByNonce).forEach((address) => {\n    heap.push(sortedByNonce[address].shift());\n  });\n\n  // Now reorder our transactions. Compare the next transactions from each account, and choose\n  // the one with the highest gas price.\n  const sortedTransactions = [];\n  while (heap.size() > 0) {\n    const best = heap.pop();\n    let address = best.from.toString(\"hex\");\n    if (sortedByNonce[address].length > 0) {\n      // Push on the next transaction from this account\n      heap.push(sortedByNonce[address].shift());\n    }\n    sortedTransactions.push(best);\n  }\n  self.pending_transactions = sortedTransactions;\n};\n\nBlockchainDouble.prototype.processCall = function(tx, blockNumber, callback) {\n  var self = this;\n\n  var runCall = function(tx, err, parentBlock) {\n    if (err) {\n      return callback(err);\n    }\n\n    // create a fake block with this fake transaction\n    self.createBlock(parentBlock, function(err, newBlock) {\n      if (err) {\n        return callback(err);\n      }\n      newBlock.transactions.push(tx);\n\n      var runArgs = {\n        tx: tx,\n        block: newBlock,\n        skipBalance: true,\n        skipNonce: true\n      };\n\n      var stateTrie = self.createStateTrie(self.data.trie_db, parentBlock.header.stateRoot);\n      var vm = self.createVMFromStateTrie(stateTrie);\n\n      vm.runTx(runArgs, function(vmerr, result) {\n        // This is a check that has been in there for awhile. I'm unsure if it's required, but it can't hurt.\n        if (vmerr && vmerr instanceof Error === false) {\n          vmerr = new Error(\"VM error: \" + vmerr);\n        }\n\n        // If we're given an error back directly, it's worse than a runtime error. Expose it and get out.\n        if (vmerr) {\n          return callback(vmerr, err);\n        }\n\n        // If no error, check for a runtime error. This can return null if no runtime error.\n        vmerr = RuntimeError.fromResults([tx], { results: [result] });\n\n        callback(vmerr, result);\n      });\n    });\n  };\n\n  // Delegate block selection\n  if (blockNumber === \"latest\") {\n    self.latestBlock(runCall.bind(null, tx));\n  } else {\n    self.getBlock(blockNumber, runCall.bind(null, tx));\n  }\n};\n\nBlockchainDouble.prototype.estimateGas = function(tx, blockNumber, callback) {\n  var self = this;\n\n  var runCall = function(tx, err, parentBlock) {\n    if (err) {\n      return callback(err);\n    }\n\n    // create a fake block with this fake transaction\n    self.createBlock(parentBlock, function(err, newBlock) {\n      if (err) {\n        return callback(err);\n      }\n      newBlock.transactions.push(tx);\n\n      var runArgs = {\n        tx: tx,\n        block: newBlock,\n        skipBalance: true,\n        skipNonce: true\n      };\n\n      var stateTrie = self.createStateTrie(self.data.trie_db, parentBlock.header.stateRoot);\n      var vm = self.createVMFromStateTrie(stateTrie);\n\n      estimateGas(vm, runArgs, err, callback);\n    });\n  };\n\n  // Delegate block selection\n  if (blockNumber === \"latest\") {\n    self.latestBlock(runCall.bind(null, tx));\n  } else {\n    self.getBlock(blockNumber, runCall.bind(null, tx));\n  }\n};\n\n/**\n * processBlock\n *\n * Process the passed in block and included transactions\n *\n * @param  {VM} vm             the vm to use when running the block\n * @param  {Block} block       block to process\n * @param  {Boolean} commit    Whether or not changes should be committed to the state\n * trie and the block appended to the end of the chain.\n * @param  {Function} callback Callback function when transaction processing is completed.\n * @return [type]              [description]\n */\nBlockchainDouble.prototype.processBlock = function(vm, block, commit, callback) {\n  var self = this;\n\n  if (typeof commit === \"function\") {\n    callback = commit;\n    commit = true;\n  }\n\n  vm.runBlock(\n    {\n      block: block,\n      generate: true,\n      skipBlockValidation: true\n    },\n    async function(vmerr, results) {\n      // This is a check that has been in there for awhile. I'm unsure if it's required, but it can't hurt.\n      if (vmerr && vmerr instanceof Error === false) {\n        vmerr = new Error(\"VM error: \" + vmerr);\n      }\n\n      // If we're given an error back directly, it's worse than a runtime error. Expose it and get out.\n      if (vmerr) {\n        callback(vmerr);\n        return;\n      }\n      // If no error, check for a runtime error. This can return null if no runtime error.\n      vmerr = RuntimeError.fromResults(block.transactions, results);\n\n      // Note, even if we have an error, some transactions may still have succeeded.\n      // Process their logs if so, returning the error at the end.\n\n      var logs = [];\n      var receipts = [];\n\n      var totalBlockGasUsage = 0;\n\n      results.results.forEach(function(result) {\n        totalBlockGasUsage += to.number(result.gasUsed);\n      });\n\n      block.header.gasUsed = utils.toBuffer(to.hex(totalBlockGasUsage));\n\n      const txTrie = new Trie();\n      const rcptTrie = new Trie();\n      const promises = [];\n      const putInTrie = (trie, key, val) => promisify(trie.put.bind(trie))(key, val);\n\n      for (var v = 0; v < results.receipts.length; v++) {\n        var result = results.results[v];\n        var receipt = results.receipts[v];\n        var tx = block.transactions[v];\n        var txHash = tx.hash();\n        var txLogs = [];\n\n        // Only process the transaction's logs if it didn't error.\n        if (result.vm.exception === 1) {\n          for (var i = 0; i < receipt.logs.length; i++) {\n            var receiptLog = receipt.logs[i];\n            var address = to.hex(receiptLog[0]);\n            var topics = [];\n\n            for (var j = 0; j < receiptLog[1].length; j++) {\n              topics.push(to.hex(receiptLog[1][j]));\n            }\n\n            var data = to.hex(receiptLog[2]);\n\n            var log = new Log({\n              logIndex: to.hex(i),\n              transactionIndex: to.hex(v),\n              transactionHash: txHash,\n              block: block,\n              address: address,\n              data: data,\n              topics: topics,\n              type: \"mined\"\n            });\n\n            logs.push(log);\n            txLogs.push(log);\n          }\n        }\n\n        let rcpt = new Receipt(\n          tx,\n          block,\n          txLogs,\n          result.gasUsed.toArrayLike(Buffer),\n          receipt.gasUsed,\n          result.createdAddress,\n          receipt.status,\n          to.hex(receipt.bitvector)\n        );\n        receipts.push(rcpt);\n\n        const rawReceipt = [receipt.status, receipt.gasUsed, receipt.bitvector, receipt.logs];\n        const rcptBuffer = utils.rlp.encode(rawReceipt);\n        const key = utils.rlp.encode(v);\n        promises.push(putInTrie(txTrie, key, tx.serialize()));\n        promises.push(putInTrie(rcptTrie, key, rcptBuffer));\n      }\n      await Promise.all(promises);\n\n      block.header.transactionsTrie = utils.toBuffer(txTrie.root);\n      block.header.receiptTrie = utils.toBuffer(rcptTrie.root);\n\n      if (commit) {\n        // Put that block on the end of the chain\n        self.putBlock(block, logs, receipts, done);\n      } else {\n        done();\n      }\n\n      function done(e) {\n        if (e) {\n          return callback(e);\n        }\n        // Note we return the vm err here too, if it exists.\n        callback(vmerr, block.transactions, results);\n      }\n    }\n  );\n};\n\n/**\n * processNextBlock\n *\n * Process the next block like a normal blockchain, pulling from the list of\n * pending transactions.\n *\n * @param  {number} timestamp at which the block is mined\n * @param  {Function} callback Callback when transaction processing is finished.\n * @return [type]              [description]\n */\nBlockchainDouble.prototype.processNextBlock = function(timestamp, callback) {\n  var self = this;\n\n  if (typeof timestamp === \"function\") {\n    callback = timestamp;\n    timestamp = undefined;\n  }\n\n  self.sortByPriceAndNonce();\n\n  // Grab only the transactions that can fit within the block\n  var currentTransactions = [];\n  var totalGasLimit = 0;\n  var maxGasLimit = to.number(self.blockGasLimit);\n\n  while (self.pending_transactions.length > 0) {\n    var tx = self.pending_transactions[0];\n    var gasLimit = to.number(tx.gasLimit);\n\n    if (totalGasLimit + gasLimit <= maxGasLimit) {\n      totalGasLimit += gasLimit;\n      self.pending_transactions.shift();\n      currentTransactions.push(tx);\n    } else {\n      // Next one won't fit. Break.\n      break;\n    }\n  }\n\n  // Remember, we ensured transactions had a valid gas limit when they were queued (in the state manager).\n  // If we run into a case where we can't process any because one is higher than the gas limit,\n  // then it's a serious issue. This should never happen, but let's check anyway.\n  if (currentTransactions.length === 0 && self.pending_transactions.length > 0) {\n    // Error like geth.\n    var error = \"Unexpected error condition: next transaction exceeds block gas limit\";\n    return callback(error);\n  }\n\n  // Create a new block meant to be the end of the chain\n  this.createBlock(function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    // Overwrite block timestamp\n    if (timestamp) {\n      self.data.blocks.last(function(err, last) {\n        if (err) {\n          return callback(err);\n        }\n        if (last && to.number(last.header.timestamp) > timestamp) {\n          self.logger.log(\n            \"Waring: Setting the block timestamp (\" + timestamp + \") that is earlier than the parent block one.\"\n          );\n        }\n      });\n      block.header.timestamp = to.hex(timestamp);\n      self.setTime(new Date(timestamp * 1000));\n    }\n    // Add transactions to the block.\n    Array.prototype.push.apply(block.transactions, currentTransactions);\n\n    self.processBlock(self.vm, block, true, callback);\n  });\n};\n\n/**\n * processTransactionTrace\n *\n * Run a previously-run transaction in the same state in which it occurred at the time it was run.\n * This will return the vm-level trace output for debugging purposes.\n *\n * Strategy:\n *\n *  1. Find block where transaction occurred\n *  2. Set state root of that block\n *  3. Rerun every transaction in that block prior to and including the requested transaction\n *  4. Send trace results back.\n *\n * @param  {[type]}   tx       [description]\n * @param  {Function} callback [description]\n * @return [type]              [description]\n */\nBlockchainDouble.prototype.processTransactionTrace = async function(hash, params, callback) {\n  const self = this;\n  const targetHash = to.hex(hash);\n  let txHashCurrentlyProcessing = \"\";\n  let txCurrentlyProcessing = null;\n  let vm;\n\n  let storageStack = {\n    currentDepth: -1,\n    stack: []\n  };\n\n  let returnVal = {\n    gas: 0,\n    returnValue: \"\",\n    structLogs: []\n  };\n\n  function stepListener(event, next) {\n    // See these docs:\n    // https://github.com/ethereum/go-ethereum/wiki/Management-APIs\n\n    const gasLeft = to.number(event.gasLeft);\n    const totalGasUsedAfterThisStep = to.number(txCurrentlyProcessing.gasLimit) - gasLeft;\n    const gasUsedThisStep = totalGasUsedAfterThisStep - returnVal.gas;\n    returnVal.gas += gasUsedThisStep;\n\n    let memory = null;\n    if (!params.disableMemory) {\n      // Get memory and break it up into 32-byte words.\n      // Note we may possibly have to pad the final word.\n      memory = Buffer.from(event.memory).toString(\"hex\");\n      memory = memory.match(/.{1,64}/g) || [];\n\n      if (memory.length > 0) {\n        const lastItem = memory[memory.length - 1];\n        if (lastItem.length < 64) {\n          memory[memory.length - 1] = lastItem + new Array(64 - lastItem.length + 1).join(\"0\");\n        }\n      }\n    }\n\n    let stack = null;\n    if (!params.disableStack) {\n      stack = event.stack.map((item) => {\n        return to.rpcDataHexString(item, 64).replace(\"0x\", \"\"); // non-0x prefixed.\n      });\n    }\n\n    let structLog = {\n      depth: event.depth,\n      error: \"\",\n      gas: gasLeft,\n      gasCost: gasUsedThisStep,\n      memory,\n      op: event.opcode.name,\n      pc: event.pc,\n      stack,\n      storage: null\n    };\n\n    if (params.disableStorage) {\n      returnVal.structLogs.push(structLog);\n      next();\n    } else {\n      structLog = self.processStorageTrace(structLog, storageStack, event, vm, function(err, structLog) {\n        if (err) {\n          return next(err);\n        }\n        returnVal.structLogs.push(structLog);\n        next();\n      });\n    }\n  }\n\n  // #1 - get block via transaction receipt\n  this.getTransactionReceipt(targetHash, function(err, receipt) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!receipt) {\n      return callback(new Error(\"Unknown transaction \" + targetHash));\n    }\n\n    let targetBlock = receipt.block;\n\n    // Get the parent of the target block\n    self.getBlock(targetBlock.header.parentHash, function(err, parent) {\n      if (err) {\n        return callback(err);\n      }\n\n      // #2 - Set state root of original block\n      var stateTrie = self.createStateTrie(self.data.trie_db, parent.header.stateRoot, {\n        // when forking we need to make sure we also copy over the forkBlockNumber,\n        // otherwise some operations will request data from the main chain at the\n        // latest block\n        forkBlockNumber: to.number(parent.header.number)\n      });\n      vm = self.createVMFromStateTrie(stateTrie);\n\n      // Prepare the \"next\" block with necessary transactions\n      self.createBlock(parent, function(err, block) {\n        if (err) {\n          return callback(err);\n        }\n\n        for (var i = 0; i < targetBlock.transactions.length; i++) {\n          var tx = targetBlock.transactions[i];\n          block.transactions.push(tx);\n\n          // After including the target transaction, that's all we need to do.\n          if (to.hex(tx.hash()) === targetHash) {\n            break;\n          }\n        }\n\n        function beforeTxListener(tx) {\n          txCurrentlyProcessing = tx;\n          txHashCurrentlyProcessing = to.hex(tx.hash());\n          if (txHashCurrentlyProcessing === targetHash) {\n            vm.on(\"step\", stepListener);\n          }\n        }\n\n        // afterTxListener cleans up everything.\n        function afterTxListener() {\n          if (txHashCurrentlyProcessing === targetHash) {\n            removeListeners();\n          }\n        }\n\n        function removeListeners() {\n          vm.removeListener(\"step\", stepListener);\n          vm.removeListener(\"beforeTx\", beforeTxListener);\n          vm.removeListener(\"afterTx\", afterTxListener);\n        }\n\n        // Listen to beforeTx and afterTx so we know when our target transaction\n        // is processing. These events will add the event listener for getting the trace data.\n        vm.on(\"beforeTx\", beforeTxListener);\n        vm.on(\"afterTx\", afterTxListener);\n\n        // Don't even let the vm try to flush the block's _cache to the stateTrie.\n        // When forking some of the data that the traced function may request will\n        // exist only on the main chain. Because we pretty much lie to the VM by\n        // telling it we DO have data in our Trie, when we really don't, it gets\n        // lost during the commit phase when it traverses the \"borrowed\" data's\n        // trie (as it may not have a valid root). Because this is a trace, and we\n        // don't need to commit the data, duck punching the `flush` method (the\n        // simplest method I could find) is fine.\n        // Remove this and you may see the infamous\n        // `Uncaught TypeError: Cannot read property 'pop' of undefined` error!\n        vm.stateManager._cache.flush = (cb) => cb();\n\n        // #3 - Process the block without committing the data.\n        self.processBlock(vm, block, false, function(err) {\n          // Ignore runtime errors, or else erroneous transactions can't be traced.\n          if (err && err.message.indexOf(\"VM Exception\") === 0) {\n            err = null;\n          }\n\n          // Just to be safe\n          removeListeners();\n\n          // #4 - send state results back\n          callback(err, returnVal);\n        });\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.processStorageTrace = function(structLog, storageStack, event, vm, callback) {\n  var name = event.opcode.name;\n\n  var argsNum = event.opcode.in;\n  var args = event.stack.slice(-argsNum).map((arg) => to.hex(arg));\n\n  if (storageStack.currentDepth > event.depth) {\n    storageStack.stack.pop();\n  }\n  if (storageStack.currentDepth < event.depth) {\n    storageStack.stack.push({});\n  }\n\n  storageStack.currentDepth = event.depth;\n\n  var key;\n  var value;\n  switch (name) {\n    case \"SSTORE\":\n      key = to.rpcDataHexString(args[1], 64).replace(\"0x\", \"\");\n      value = to.rpcDataHexString(args[0], 64).replace(\"0x\", \"\");\n\n      // use Object.assign to prevent future steps from overwriting this step's storage values\n      structLog.storage = Object.assign({}, storageStack.stack[storageStack.currentDepth]);\n\n      callback(null, structLog);\n      // assign after callback because this storage change actually takes\n      // effect _after_ this opcode executes\n      storageStack.stack[storageStack.currentDepth][key] = value;\n      break;\n    case \"SLOAD\":\n      // this one's more fun, we need to get the value the contract is loading from current storage\n      key = to.rpcDataHexString(args[0], 64).replace(\"0x\", \"\");\n\n      vm.stateManager.getContractStorage(event.address, \"0x\" + key, function(err, result) {\n        if (err) {\n          return callback(err);\n        }\n\n        value = to.rpcDataHexString(result, 64).replace(\"0x\", \"\");\n        storageStack.stack[storageStack.currentDepth][key] = value;\n        // use Object.assign to prevent future steps from overwriting this step's storage values\n        structLog.storage = Object.assign({}, storageStack.stack[storageStack.currentDepth]);\n        callback(null, structLog);\n      });\n      break;\n    default:\n      // use Object.assign to prevent future steps from overwriting this step's storage values\n      structLog.storage = Object.assign({}, storageStack.stack[storageStack.currentDepth]);\n      callback(null, structLog);\n  }\n};\n\nBlockchainDouble.prototype.getAccount = function(address, number, callback) {\n  var self = this;\n\n  this.getBlock(number, function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    var trie = self.stateTrie;\n\n    // Manipulate the state root in place to maintain checkpoints\n    var currentStateRoot = trie.root;\n    self.stateTrie.root = block.header.stateRoot;\n\n    trie.get(utils.toBuffer(address), function(err, data) {\n      // Finally, put the stateRoot back for good\n      trie.root = currentStateRoot;\n\n      if (err) {\n        return callback(err);\n      }\n\n      var account = new Account(data);\n\n      callback(null, account);\n    });\n  });\n};\n\nBlockchainDouble.prototype.getNonce = function(address, number, callback) {\n  this.getAccount(address, number, function(err, account) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, account.nonce);\n  });\n};\n\nBlockchainDouble.prototype.getBalance = function(address, number, callback) {\n  this.getAccount(address, number, function(err, account) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, account.balance);\n  });\n};\n\n// Note! Storage values are returned RLP encoded!\nBlockchainDouble.prototype.getStorage = function(address, position, number, callback) {\n  var self = this;\n\n  this.getBlock(number, function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    var trie = self.stateTrie;\n\n    // Manipulate the state root in place to maintain checkpoints\n    var currentStateRoot = trie.root;\n    self.stateTrie.root = block.header.stateRoot;\n\n    trie.get(utils.toBuffer(address), function(err, data) {\n      if (err != null) {\n        // Put the stateRoot back if there's an error\n        trie.root = currentStateRoot;\n        return callback(err);\n      }\n\n      var account = new Account(data);\n\n      trie.root = account.stateRoot;\n\n      trie.get(utils.setLengthLeft(utils.toBuffer(position), 32), function(err, value) {\n        // Finally, put the stateRoot back for good\n        trie.root = currentStateRoot;\n\n        if (err != null) {\n          return callback(err);\n        }\n\n        callback(null, value);\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.getCode = function(address, number, callback) {\n  var self = this;\n\n  this.getBlock(number, function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    var trie = self.stateTrie;\n\n    // Manipulate the state root in place to maintain checkpoints\n    var currentStateRoot = trie.root;\n    self.stateTrie.root = block.header.stateRoot;\n\n    trie.get(utils.toBuffer(address), function(err, data) {\n      if (err != null) {\n        // Put the stateRoot back if there's an error\n        trie.root = currentStateRoot;\n        return callback(err);\n      }\n\n      var account = new Account(data);\n\n      account.getCode(trie, function(err, code) {\n        // Finally, put the stateRoot back for good\n        trie.root = currentStateRoot;\n\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, code);\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.getTransaction = function(hash, callback) {\n  hash = to.hex(hash);\n\n  this.data.transactions.get(hash, function(err, tx) {\n    if (err) {\n      if (err.notFound) {\n        return callback(null, null);\n      } else {\n        return callback(err);\n      }\n    }\n    callback(null, tx);\n  });\n};\n\nBlockchainDouble.prototype.getTransactionReceipt = function(hash, callback) {\n  hash = to.hex(hash);\n  const pendingTxs = this.pending_transactions;\n\n  for (var i = 0; i < pendingTxs.length; i++) {\n    let pendingTxHash = to.hex(pendingTxs[i].hash());\n    if (hash === pendingTxHash) {\n      return callback(null, { tx: pendingTxs[i] });\n    }\n  }\n\n  this.data.transactionReceipts.get(hash, function(err, receipt) {\n    if (err) {\n      if (err.notFound) {\n        return callback(null, null);\n      } else {\n        return callback(err);\n      }\n    }\n\n    callback(err, receipt);\n  });\n};\n\nBlockchainDouble.prototype.getBlockLogs = function(number, callback) {\n  var self = this;\n  this.getEffectiveBlockNumber(number, function(err, effective) {\n    if (err) {\n      return callback(err);\n    }\n    self.data.blockLogs.get(effective, callback);\n  });\n};\n\nBlockchainDouble.prototype.getHeight = function(callback) {\n  this.data.blocks.length(function(err, length) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, length - 1);\n  });\n};\n\nBlockchainDouble.prototype.currentTime = function() {\n  return ((new Date().getTime() / 1000) | 0) + this.timeAdjustment;\n};\n\nBlockchainDouble.prototype.increaseTime = function(seconds) {\n  if (seconds < 0) {\n    seconds = 0;\n  }\n  this.timeAdjustment += seconds;\n  return this.timeAdjustment;\n};\n\nBlockchainDouble.prototype.setTime = function(date) {\n  var now = (new Date().getTime() / 1000) | 0;\n  var start = (date.getTime() / 1000) | 0;\n  this.timeAdjustment = start - now;\n};\n\nBlockchainDouble.prototype.close = function(callback) {\n  this.data.close(callback);\n};\n\nmodule.exports = BlockchainDouble;\n","module.exports = require(\"merkle-patricia-tree\");","module.exports = require(\"level-sublevel\");","// var to = require(\"../utils/to\");\nvar Transaction = require(\"../utils/transaction\");\n\nconst decode = function(json, done) {\n  const options = {\n    hash: json.hash,\n    nonce: json.nonce,\n    value: json.value,\n    to: json.to,\n    from: json.from,\n    gasLimit: json.gas || json.gasLimit,\n    gasPrice: json.gasPrice,\n    data: json.data,\n    v: json.v,\n    r: json.r,\n    s: json.s\n  };\n\n  // databases generated before ganache-core@2.3.2 didn't have a `_type` and\n  // and were always fake signed. So if _type is undefined it is \"fake\" (even\n  // if we have a valid signature that can generate the tx's `from`).\n  const type = json._type === undefined ? Transaction.types.fake : json._type;\n  const tx = Transaction.fromJSON(options, type);\n\n  // Commenting this out because we don't want to throw if the json.hash we\n  // put in is different that the tx.hash() calculation we now have. There\n  // may have been bug fixes to the way transactions are hashed in future\n  // versions of ganache-core, but we still want tobe able to read in\n  // transactions from previously saved databases!\n  // if (to.hex(tx.hash()) !== json.hash) {\n  //   const e = new Error(\n  //     \"DB consistency check: Decoded transaction hash \" +\n  //       \"didn't match encoded hash. Expected: \" +\n  //       json.hash +\n  //       \"; actual: \" +\n  //       to.hex(tx.hash())\n  //   );\n  //   return done(e);\n  // }\n\n  done(null, tx);\n};\n\nconst encode = function(tx, done) {\n  const encoded = tx.encode();\n  done(null, encoded);\n};\n\nmodule.exports = {\n  encode,\n  decode\n};\n","var inherits = require(\"util\").inherits;\n\n// raised when the transaction is rejected prior to running it in the EVM.\nfunction TXRejectedError(message) {\n  // Why not just Error.apply(this, [message])? See\n  // https://gist.github.com/justmoon/15511f92e5216fa2624b#anti-patterns\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = message;\n}\n\ninherits(TXRejectedError, Error);\n\nmodule.exports = TXRejectedError;\n","var to = require(\"./to\");\n\nmodule.exports = {\n  toJSON: function(block, includeFullTransactions) {\n    return {\n      number: to.rpcQuantityHexString(block.header.number),\n      hash: to.hex(block.hash()),\n      parentHash: to.hex(block.header.parentHash), // common.hash\n      mixHash: to.hex(block.header.mixHash),\n      nonce: to.rpcDataHexString(to.hex(block.header.nonce), 16),\n      sha3Uncles: to.hex(block.header.uncleHash),\n      logsBloom: to.hex(block.header.bloom),\n      transactionsRoot: to.hex(block.header.transactionsTrie),\n      stateRoot: to.hex(block.header.stateRoot),\n      receiptsRoot: to.hex(block.header.receiptTrie),\n      miner: to.hex(block.header.coinbase),\n      difficulty: to.rpcQuantityHexString(block.header.difficulty),\n      totalDifficulty: to.rpcQuantityHexString(block.header.difficulty), // TODO: Figure out what to do here.\n      extraData: to.rpcDataHexString(block.header.extraData),\n      size: to.hex(1000), // TODO: Do something better here\n      gasLimit: to.rpcQuantityHexString(block.header.gasLimit),\n      gasUsed: to.rpcQuantityHexString(block.header.gasUsed),\n      timestamp: to.rpcQuantityHexString(block.header.timestamp),\n      transactions: block.transactions.map(function(tx) {\n        if (includeFullTransactions) {\n          return tx.toJsonRpc(block);\n        } else {\n          return to.hex(tx.hash());\n        }\n      }),\n      uncles: [] // block.uncleHeaders.map(function(uncleHash) {return to.hex(uncleHash)})\n    };\n  }\n};\n","// make sourcemaps work!\nrequire(\"source-map-support/register\");\n\nconst Provider = require(\"./lib/provider\");\nconst Server = require(\"./lib/server\");\n\n// This interface exists so as not to cause breaking changes.\nmodule.exports = {\n  server: function(options) {\n    return Server.create(options);\n  },\n  provider: function(options) {\n    return new Provider(options);\n  },\n  _webpacked: true\n};\n","module.exports = require(\"web3-provider-engine\");","module.exports = require(\"web3-provider-engine/subproviders/subscriptions\");","var Subprovider = require(\"web3-provider-engine/subproviders/subprovider.js\");\nvar inherits = require(\"util\").inherits;\n\ninherits(RequestFunnel, Subprovider);\n\nmodule.exports = RequestFunnel;\n\n// See if any payloads for the specified methods are marked as external.\n// If they are external, and match the method list, process them one at\n// a time.\nfunction RequestFunnel() {\n  // We use an object here for O(1) lookups (speed).\n  this.methods = {\n    eth_call: true,\n    eth_getStorageAt: true,\n    eth_sendTransaction: true,\n    eth_sendRawTransaction: true,\n\n    // Ensure block filter and filter changes are process one at a time\n    // as well so filter requests that come in after a transaction get\n    // processed once that transaction has finished processing.\n    eth_newBlockFilter: true,\n    eth_getFilterChanges: true,\n    eth_getFilterLogs: true\n  };\n  this.queue = [];\n  this.isWorking = false;\n}\n\nRequestFunnel.prototype.handleRequest = function(payload, next, end) {\n  if (payload.external !== true || this.methods[payload.method] !== true) {\n    return next();\n  }\n\n  this.queue.push([payload, next]);\n\n  if (this.isWorking === false) {\n    this.processNext();\n  }\n};\n\nRequestFunnel.prototype.processNext = function() {\n  var self = this;\n\n  if (this.queue.length === 0) {\n    this.isWorking = false;\n    return;\n  }\n\n  this.isWorking = true;\n\n  var item = this.queue.shift();\n  var next = item[1];\n\n  next(function(error, request, cb) {\n    if (error) {\n      return cb(error);\n    }\n    cb();\n    self.processNext();\n  });\n};\n","// It's unforutnate we have to have this subprovider, but it's because\n// we instamine, and web3 isn't written in a way that supports instamining\n// (i.e., it sets up the filter after the transaction has been processed).\n// This block filter will ensure that each block filter will always see\n// the change from the last block to the current block.\n//\n// Note: An added benefit of this is that it shaves off a signifcant\n// amount of time from tests that use web3 and block filters.\n\nvar Subprovider = require(\"web3-provider-engine/subproviders/subprovider.js\");\nvar inherits = require(\"util\").inherits;\nvar async = require(\"async\");\nvar to = require(\"../utils/to\");\n\ninherits(DelayedBlockFilter, Subprovider);\n\nmodule.exports = DelayedBlockFilter;\n\nfunction DelayedBlockFilter() {\n  this.watching = {};\n}\n\nDelayedBlockFilter.prototype.handleRequest = function(payload, next, end) {\n  if (payload.method === \"eth_newBlockFilter\") {\n    return this.handleNewBlockFilter(payload, next, end);\n  }\n  if (payload.method === \"eth_getFilterChanges\") {\n    return this.handleGetFilterChanges(payload, next, end);\n  }\n\n  next();\n};\n\nDelayedBlockFilter.prototype.handleNewBlockFilter = function(payload, next, end) {\n  var self = this;\n\n  // Let this filter process and add it to our watch list.\n  next(function(err, result, cb) {\n    if (err) {\n      return cb();\n    }\n    self.watching[result] = true;\n    cb();\n  });\n};\n\nDelayedBlockFilter.prototype.handleGetFilterChanges = function(payload, next, end) {\n  var self = this;\n  var filterId = payload.params[0];\n\n  if (!this.watching[filterId]) {\n    return next();\n  }\n\n  // Get the changes, and then alter the result.\n  next(function(err, result, cb) {\n    if (err) {\n      return cb();\n    }\n\n    var currentBlockHash;\n    var previousBlockHash;\n    var blockNumber;\n\n    async.series(\n      [\n        function(c) {\n          // If we have a result, use it.\n          if (result.length !== 0) {\n            currentBlockHash = result[0];\n            c();\n          } else {\n            // Otherwise, get the current block number.\n            self.emitPayload(\n              {\n                method: \"eth_blockNumber\"\n              },\n              function(err, res) {\n                if (err) {\n                  return c(err);\n                }\n                blockNumber = to.number(res.result);\n                c();\n              }\n            );\n          }\n        },\n        function(c) {\n          // If we got a block number above, meaning, we didn't get a block hash,\n          // skip this step.\n          if (blockNumber) {\n            return c();\n          }\n\n          // If not skipped, then we got a block hash, and we need to get a block number from it.\n          self.emitPayload(\n            {\n              method: \"eth_getBlockByHash\",\n              params: [currentBlockHash, false]\n            },\n            function(err, res) {\n              if (err) {\n                return c(err);\n              }\n              blockNumber = to.number(res.result.number);\n              c();\n            }\n          );\n        },\n        function(c) {\n          // If we're at block 0, return no changes. See final function below.\n          blockNumber = to.number(blockNumber);\n          if (blockNumber === 0) {\n            previousBlockHash = undefined;\n            return c();\n          }\n\n          // If at this point, we do have a block number, so let's subtract one\n          // from it and get the block hash of the block before it.\n          blockNumber = blockNumber - 1;\n          self.emitPayload(\n            {\n              method: \"eth_getBlockByNumber\",\n              params: [blockNumber, false]\n            },\n            function(err, res) {\n              if (err) {\n                return c(err);\n              }\n              previousBlockHash = res.result.hash;\n              c();\n            }\n          );\n        }\n      ],\n      function(err) {\n        if (err) {\n          // Unfortunately the subprovider code doesn't let us return an error\n          // through the callback cb(). So we'll just ignore it.... (famous last words).\n        }\n\n        // If we got the previous block, use it. Otherwise do nothing.\n        // Then stop watching because we only want on getFilterChanges to react this way.\n        if (previousBlockHash) {\n          result[0] = previousBlockHash;\n        }\n\n        delete self.watching[filterId];\n        cb();\n      }\n    );\n  });\n};\n","var Subprovider = require(\"web3-provider-engine/subproviders/subprovider.js\");\nvar inherits = require(\"util\").inherits;\n\ninherits(GethDefaults, Subprovider);\n\nmodule.exports = GethDefaults;\n\nfunction GethDefaults() {}\n\n// Massage eth_estimateGas requests, setting default data (e.g., from) if\n// not specified. This is here specifically to make the testrpc\n// react like Geth.\nGethDefaults.prototype.handleRequest = function(payload, next, end) {\n  if (payload.method !== \"eth_estimateGas\" && payload.method !== \"eth_call\") {\n    return next();\n  }\n\n  var params = payload.params[0];\n\n  if (params.from == null) {\n    this.emitPayload(\n      {\n        method: \"eth_coinbase\"\n      },\n      function(err, result) {\n        if (err) {\n          return end(err);\n        }\n\n        var coinbase = result.result;\n\n        params.from = coinbase;\n        next();\n      }\n    );\n  } else {\n    next();\n  }\n};\n","var utils = require(\"ethereumjs-util\");\nvar inherits = require(\"util\").inherits;\nvar StateManager = require(\"../statemanager.js\");\nvar to = require(\"../utils/to\");\nvar TXRejectedError = require(\"../utils/txrejectederror\");\n\nvar blockHelper = require(\"../utils/block_helper\");\nvar pkg = require(\"../../package.json\");\nconst { BlockOutOfRangeError } = require(\"../utils/errorhelper\");\n\nvar Subprovider = require(\"web3-provider-engine/subproviders/subprovider.js\");\n\ninherits(GethApiDouble, Subprovider);\n\nfunction GethApiDouble(options, provider) {\n  var self = this;\n\n  this.state = options.state || new StateManager(options, provider);\n  this.options = options;\n  this.initialized = false;\n\n  this.initialization_error = null;\n  this.post_initialization_callbacks = [];\n\n  this.state.initialize(function(err) {\n    if (err) {\n      self.initialization_error = err;\n    }\n    self.initialized = true;\n\n    var callbacks = self.post_initialization_callbacks;\n    self.post_initialization_callbacks = [];\n\n    callbacks.forEach(function(callback) {\n      setImmediate(function() {\n        callback(self.initialization_error, self.state);\n      });\n    });\n  });\n}\n\nGethApiDouble.prototype.waitForInitialization = function(callback) {\n  var self = this;\n  if (self.initialized === false) {\n    self.post_initialization_callbacks.push(callback);\n  } else {\n    callback(self.initialization_error, self.state);\n  }\n};\n\n// Function to not pass methods through until initialization is finished\nGethApiDouble.prototype.handleRequest = function(payload, next, end) {\n  var self = this;\n\n  if (self.initialization_error != null) {\n    return end(self.initialization_error);\n  }\n\n  if (self.initialized === false) {\n    self.waitForInitialization(self.getDelayedHandler(payload, next, end));\n    return;\n  }\n\n  var method = self[payload.method];\n\n  if (method == null) {\n    return end(new Error(\"Method \" + payload.method + \" not supported.\"));\n  }\n\n  var params = payload.params || [];\n  var args = [].concat(params);\n\n  var addedBlockParam = false;\n\n  if (self.requiresDefaultBlockParameter(payload.method) && args.length < method.length - 1) {\n    args.push(\"latest\");\n    addedBlockParam = true;\n  }\n\n  args.push(end);\n\n  // avoid crash by checking to make sure that we haven't specified too many arguments\n  if (\n    args.length > method.length ||\n    (method.minLength !== undefined && args.length < method.minLength) ||\n    (method.minLength === undefined && args.length < method.length)\n  ) {\n    var errorMessage = `Incorrect number of arguments. Method '${payload.method}' requires `;\n    if (method.minLength) {\n      errorMessage += `between ${method.minLength - 1} and ${method.length - 1} arguments. `;\n    } else {\n      errorMessage += `exactly ${method.length - 1} arguments. `;\n    }\n\n    if (addedBlockParam) {\n      errorMessage += \"Including the implicit block argument, r\";\n    } else {\n      // new sentence, capitalize it.\n      errorMessage += \"R\";\n    }\n    errorMessage += `equest specified ${args.length - 1} arguments: ${JSON.stringify(args)}.`;\n\n    return end(new Error(errorMessage));\n  }\n\n  method.apply(self, args);\n};\n\nGethApiDouble.prototype.getDelayedHandler = function(payload, next, end) {\n  var self = this;\n  return function(err, state) {\n    if (err) {\n      end(err);\n    }\n    self.handleRequest(payload, next, end);\n  };\n};\n\nGethApiDouble.prototype.requiresDefaultBlockParameter = function(method) {\n  // object for O(1) lookup.\n  var methods = {\n    eth_getBalance: true,\n    eth_getCode: true,\n    eth_getTransactionCount: true,\n    eth_getStorageAt: true,\n    eth_call: true,\n    eth_estimateGas: true\n  };\n\n  return methods[method] === true;\n};\n\n// Handle individual requests.\n\nGethApiDouble.prototype.eth_accounts = function(callback) {\n  callback(null, Object.keys(this.state.accounts));\n};\n\nGethApiDouble.prototype.eth_blockNumber = function(callback) {\n  this.state.blockNumber(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, to.hex(result));\n  });\n};\n\nGethApiDouble.prototype.eth_coinbase = function(callback) {\n  callback(null, this.state.coinbase);\n};\n\nGethApiDouble.prototype.eth_mining = function(callback) {\n  callback(null, this.state.is_mining);\n};\n\nGethApiDouble.prototype.eth_hashrate = function(callback) {\n  callback(null, \"0x0\");\n};\n\nGethApiDouble.prototype.eth_gasPrice = function(callback) {\n  callback(null, utils.addHexPrefix(this.state.gasPrice()));\n};\n\nGethApiDouble.prototype.eth_getBalance = function(address, blockNumber, callback) {\n  this.state.getBalance(address, blockNumber, callback);\n};\n\nGethApiDouble.prototype.eth_getCode = function(address, blockNumber, callback) {\n  this.state.getCode(address, blockNumber, callback);\n};\n\nGethApiDouble.prototype.eth_getBlockByNumber = function(blockNumber, includeFullTransactions, callback) {\n  this.state.blockchain.getBlock(blockNumber, function(err, block) {\n    if (err) {\n      if (err instanceof BlockOutOfRangeError) {\n        return callback(null, null);\n      } else {\n        return callback(err);\n      }\n    }\n\n    callback(null, blockHelper.toJSON(block, includeFullTransactions));\n  });\n};\n\nGethApiDouble.prototype.eth_getBlockByHash = function(txHash, includeFullTransactions, callback) {\n  this.eth_getBlockByNumber.apply(this, arguments);\n};\n\nGethApiDouble.prototype.eth_getBlockTransactionCountByNumber = function(blockNumber, callback) {\n  this.state.blockchain.getBlock(blockNumber, function(err, block) {\n    if (err) {\n      if (err instanceof BlockOutOfRangeError) {\n        // block doesn't exist\n        return callback(null, null);\n      }\n      return callback(err);\n    }\n    callback(null, to.rpcQuantityHexString(block.transactions.length));\n  });\n};\n\nGethApiDouble.prototype.eth_getBlockTransactionCountByHash = function(blockHash, callback) {\n  this.eth_getBlockTransactionCountByNumber.apply(this, arguments);\n};\n\nGethApiDouble.prototype.eth_getTransactionReceipt = function(hash, callback) {\n  this.state.getTransactionReceipt(hash, function(err, receipt) {\n    if (err) {\n      return callback(err);\n    }\n\n    var result = null;\n\n    if (receipt && receipt.block) {\n      result = receipt.toJSON();\n    }\n    callback(null, result);\n  });\n};\n\nGethApiDouble.prototype.eth_getTransactionByHash = function(hash, callback) {\n  this.state.getTransactionReceipt(hash, function(err, receipt) {\n    if (err) {\n      return callback(err);\n    }\n\n    var result = null;\n\n    if (receipt) {\n      // if there is no block then the transaction is still pending\n      if (!receipt.block) {\n        // assemble the block object with null values for pending transactions\n        receipt.block = {\n          transactions: [],\n          hash: () => {\n            return null;\n          },\n          header: { number: null }\n        };\n\n        result = receipt.tx.toJsonRpc(receipt.block);\n      } else {\n        result = receipt.tx.toJsonRpc(receipt.block);\n      }\n    }\n    callback(null, result);\n  });\n};\n\nGethApiDouble.prototype.eth_getTransactionByBlockHashAndIndex = function(hashOrNumber, index, callback) {\n  index = to.number(index);\n\n  this.state.getBlock(hashOrNumber, function(err, block) {\n    if (err) {\n      // block doesn't exist by that hash\n      if (err.notFound) {\n        return callback(null, null);\n      } else {\n        return callback(err);\n      }\n    }\n\n    if (index >= block.transactions.length) {\n      return callback(new Error(\"Transaction at index \" + to.hex(index) + \" does not exist in block.\"));\n    }\n\n    var tx = block.transactions[index];\n    var result = tx.toJsonRpc(block);\n\n    callback(null, result);\n  });\n};\n\nGethApiDouble.prototype.eth_getTransactionByBlockNumberAndIndex = function(hashOrNumber, index, callback) {\n  this.eth_getTransactionByBlockHashAndIndex(hashOrNumber, index, callback);\n};\n\nGethApiDouble.prototype.eth_getTransactionCount = function(address, blockNumber, callback) {\n  this.state.getTransactionCount(address, blockNumber, (err, count) => {\n    if (err instanceof BlockOutOfRangeError) {\n      return callback(null, null);\n    }\n    return callback(err, count);\n  });\n};\n\nGethApiDouble.prototype.eth_sign = function(address, dataToSign, callback) {\n  var result;\n  var error;\n\n  try {\n    result = this.state.sign(address, dataToSign);\n  } catch (e) {\n    error = e;\n  }\n\n  callback(error, result);\n};\n\nGethApiDouble.prototype.eth_signTypedData = function(address, typedDataToSign, callback) {\n  var result;\n  var error;\n\n  try {\n    result = this.state.signTypedData(address, typedDataToSign);\n  } catch (e) {\n    error = e;\n  }\n\n  callback(error, result);\n};\n\nGethApiDouble.prototype.eth_sendTransaction = function(txData, callback) {\n  this.state.queueTransaction(\"eth_sendTransaction\", txData, null, callback);\n};\n\nGethApiDouble.prototype.eth_sendRawTransaction = function(rawTx, callback) {\n  let data;\n  if (rawTx) {\n    data = to.buffer(rawTx);\n  }\n\n  if (data === undefined) {\n    throw new TXRejectedError(\"rawTx must be a string, JSON-encoded Buffer, or Buffer.\");\n  }\n\n  this.state.queueRawTransaction(data, callback);\n};\n\nGethApiDouble.prototype.eth_call = function(txData, blockNumber, callback) {\n  if (!txData.gas) {\n    txData.gas = this.state.blockchain.blockGasLimit;\n  }\n\n  this.state.queueTransaction(\"eth_call\", txData, blockNumber, callback); // :(\n};\n\nGethApiDouble.prototype.eth_estimateGas = function(txData, blockNumber, callback) {\n  if (!txData.gas) {\n    txData.gas = this.state.blockchain.blockGasLimit;\n  }\n  this.state.queueTransaction(\"eth_estimateGas\", txData, blockNumber, callback);\n};\n\nGethApiDouble.prototype.eth_getStorageAt = function(address, position, blockNumber, callback) {\n  this.state.queueStorage(address, position, blockNumber, callback);\n};\n\nGethApiDouble.prototype.eth_newBlockFilter = function(callback) {\n  var filterId = utils.addHexPrefix(utils.intToHex(this.state.latestFilterId));\n  this.state.latestFilterId += 1;\n  callback(null, filterId);\n};\n\nGethApiDouble.prototype.eth_getFilterChanges = function(filterId, callback) {\n  var blockHash = this.state\n    .latestBlock()\n    .hash()\n    .toString(\"hex\");\n  // Mine a block after each request to getFilterChanges so block filters work.\n  this.state.mine();\n  callback(null, [blockHash]);\n};\n\nGethApiDouble.prototype.eth_getLogs = function(filter, callback) {\n  this.state.getLogs(filter, callback);\n};\n\nGethApiDouble.prototype.eth_uninstallFilter = function(filterId, callback) {\n  callback(null, true);\n};\n\nGethApiDouble.prototype.eth_protocolVersion = function(callback) {\n  callback(null, \"63\");\n};\n\nGethApiDouble.prototype.bzz_hive = function(callback) {\n  callback(null, []);\n};\n\nGethApiDouble.prototype.bzz_info = function(callback) {\n  callback(null, []);\n};\n\nGethApiDouble.prototype.shh_version = function(callback) {\n  callback(null, \"2\");\n};\n\nGethApiDouble.prototype.eth_getCompilers = function(callback) {\n  callback(null, []);\n};\n\nGethApiDouble.prototype.eth_syncing = function(callback) {\n  callback(null, false);\n};\n\nGethApiDouble.prototype.net_listening = function(callback) {\n  callback(null, true);\n};\n\nGethApiDouble.prototype.net_peerCount = function(callback) {\n  callback(null, 0);\n};\n\nGethApiDouble.prototype.web3_clientVersion = function(callback) {\n  callback(null, \"EthereumJS TestRPC/v\" + pkg.version + \"/ethereum-js\");\n};\n\nGethApiDouble.prototype.web3_sha3 = function(string, callback) {\n  callback(null, to.hex(utils.sha3(string)));\n};\n\nGethApiDouble.prototype.net_version = function(callback) {\n  // net_version returns a string containing a base 10 integer.\n  callback(null, this.state.net_version + \"\");\n};\n\nGethApiDouble.prototype.miner_start = function(threads, callback) {\n  if (!callback && typeof threads === \"function\") {\n    callback = threads;\n    threads = null;\n  }\n\n  this.state.startMining(function(err) {\n    callback(err, true);\n  });\n};\n\n// indicate that `miner_start` only requires one argument (the callback)\nGethApiDouble.prototype.miner_start.minLength = 1;\n\nGethApiDouble.prototype.miner_stop = function(callback) {\n  this.state.stopMining(function(err) {\n    callback(err, true);\n  });\n};\n\nGethApiDouble.prototype.rpc_modules = function(callback) {\n  // returns the availible api modules and versions\n  callback(null, { eth: \"1.0\", net: \"1.0\", rpc: \"1.0\", web3: \"1.0\", evm: \"1.0\", personal: \"1.0\" });\n};\n\nGethApiDouble.prototype.personal_listAccounts = function(callback) {\n  callback(null, Object.keys(this.state.personal_accounts));\n};\n\nGethApiDouble.prototype.personal_newAccount = function(password, callback) {\n  var account = this.state.createAccount({ generate: true });\n  this.state.accounts[account.address.toLowerCase()] = account;\n  this.state.personal_accounts[account.address.toLowerCase()] = true;\n  this.state.account_passwords[account.address.toLowerCase()] = password;\n  callback(null, account.address);\n};\n\nGethApiDouble.prototype.personal_importRawKey = function(rawKey, password, callback) {\n  var account = this.state.createAccount({ secretKey: rawKey });\n  this.state.accounts[account.address.toLowerCase()] = account;\n  this.state.personal_accounts[account.address.toLowerCase()] = true;\n  this.state.account_passwords[account.address.toLowerCase()] = password;\n  callback(null, account.address);\n};\n\nGethApiDouble.prototype.personal_lockAccount = function(address, callback) {\n  var account = this.state.personal_accounts[address.toLowerCase()];\n  if (account !== true) {\n    var error = \"Account not found\";\n    return callback(error);\n  }\n  delete this.state.unlocked_accounts[address.toLowerCase()];\n  callback(null, true);\n};\n\nGethApiDouble.prototype.personal_unlockAccount = function(address, password, duration, callback) {\n  // FIXME handle duration\n  var account = this.state.personal_accounts[address.toLowerCase()];\n  if (account !== true) {\n    var accountError = \"Account not found\";\n    return callback(accountError);\n  }\n\n  var storedPassword = this.state.account_passwords[address.toLowerCase()];\n  if (storedPassword !== undefined && storedPassword !== password) {\n    var passwordError = \"Invalid password\";\n    return callback(passwordError);\n  }\n\n  this.state.unlocked_accounts[address.toLowerCase()] = true;\n  callback(null, true);\n};\n\nGethApiDouble.prototype.personal_sendTransaction = function(txData, password, callback) {\n  if (txData.from == null) {\n    var error = \"Sender not found\";\n    callback(error);\n    return;\n  }\n\n  var from = utils.addHexPrefix(txData.from).toLowerCase();\n\n  var self = this;\n  self.personal_unlockAccount(from, password, null, function(err) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.state.queueTransaction(\"eth_sendTransaction\", txData, null, function(err, ret) {\n      self.state.unlocked_accounts[from.toLowerCase()] = false;\n      callback(err, ret);\n    });\n  });\n};\n\n/* Functions for testing purposes only. */\n\nGethApiDouble.prototype.evm_snapshot = function(callback) {\n  this.state.snapshot(callback);\n};\n\nGethApiDouble.prototype.evm_revert = function(snapshotId, callback) {\n  this.state.revert(snapshotId, callback);\n};\n\nGethApiDouble.prototype.evm_increaseTime = function(seconds, callback) {\n  callback(null, this.state.blockchain.increaseTime(seconds));\n};\n\nGethApiDouble.prototype.evm_setTime = function(date, callback) {\n  callback(null, this.state.blockchain.setTime(date));\n};\n\nGethApiDouble.prototype.evm_mine = function(timestamp, callback) {\n  if (typeof timestamp === \"function\") {\n    callback = timestamp;\n    timestamp = undefined;\n  }\n  this.state.processBlock(timestamp, function(err) {\n    if (err) {\n      return callback(err);\n    }\n    callback(err, \"0x0\");\n  });\n};\n\n// indicate that `evm_mine` only requires one argument (the callback)\nGethApiDouble.prototype.evm_mine.minLength = 1;\n\nGethApiDouble.prototype.debug_traceTransaction = function(txHash, params, callback) {\n  if (typeof params === \"function\") {\n    callback = params;\n    params = [];\n  }\n\n  this.state.queueTransactionTrace(txHash, params, callback);\n};\n\n/*\n  RPC AUDIT:\n  TODO ETH: eth_getUncleCountByBlockHash, eth_getUncleCountByBlockNumber, eth_getUncleByBlockHashAndIndex,\n        eth_getUncleByBlockNumberAndIndex, eth_getWork, eth_submitWork, eth_submitHashrate\n\n  TODO DB: db_putString, db_getString, db_putHex, db_getHex\n\n  TODO WHISPER: shh_post, shh_newIdentity, shh_hasIdentity, shh_newGroup, shh_addToGroup,\n        shh_newFilter, shh_uninstallFilter, shh_getFilterChanges, shh_getMessages\n*/\n\n/**\n * Returns the number of uncles in a block from a block matching the given block hash.\n *\n * @param {DATA, 32 Bytes} hash - hash of a block.\n * @callback callback\n * @param {error} err - Error Object\n * @param {QUANTITY} result - integer of the number of uncles in this block.\n */\nGethApiDouble.prototype.eth_getUncleCountByBlockHash = function(hash, callback) {\n  callback(null, \"0x0\");\n};\n\n/**\n * Returns the number of uncles in a block from a block matching the given block number.\n *\n * @param {QUANTITY} blockNumber -\n *  ^integer of a block number, or the string \"latest\", \"earliest\" or \"pending\". Ex: '0xe8', // 232\n * @callback callback\n * @param {error} err - Error Object\n * @param {QUANTITY} result - integer of the number of uncles in this block.\n */\nGethApiDouble.prototype.eth_getUncleCountByBlockNumber = function(blockNumber, callback) {\n  callback(null, \"0x0\");\n};\n\n/**\n * Returns information about a uncle of a block by hash and uncle index position.\n *\n * @param {DATA, 32 Bytes} hash - hash of a block\n * @param {QUANTITY} index - the uncle's index position.\n * @callback callback\n * @param {error} err - Error Object\n * @param {Object} result - A block object,\n */\nGethApiDouble.prototype.eth_getUncleByBlockHashAndIndex = function(hash, index, callback) {\n  callback(null, {});\n};\n\n/**\n * Returns information about a uncle of a block by number and uncle index position.\n *\n * @param {QUANTITY} blockNumber -\n * ^a block number, or the string \"earliest\", \"latest\" or \"pending\", as in the default block parameter.\n * @param {QUANTITY} uncleIndex - the uncle's index position.\n * @callback callback\n * @param {error} err - Error object\n * @param {Object} resutl - A block object,\n */\nGethApiDouble.prototype.eth_getUncleByBlockNumberAndIndex = function(blockNumber, uncleIndex, callback) {\n  callback(null, {});\n};\n\n/**\n * Returns: An Array with the following elements\n * 1: DATA, 32 Bytes - current block header pow-hash\n * 2: DATA, 32 Bytes - the seed hash used for the DAG.\n * 3: DATA, 32 Bytes - the boundary condition (\"target\"), 2^256 / difficulty.\n *\n * @param {QUANTITY} filterId - A filter id\n * @callback callback\n * @param {error} err - Error object\n * @param {Array} result - the hash of the current block, the seedHash, and the boundary condition to be met (\"target\").\n */\nGethApiDouble.prototype.eth_getWork = function(filterId, callback) {\n  callback(null, []);\n};\n\n/**\n * Used for submitting a proof-of-work solution\n *\n * @param {DATA, 8 Bytes} nonce - The nonce found (64 bits)\n * @param {DATA, 32 Bytes} powHash - The header's pow-hash (256 bits)\n * @param {DATA, 32 Bytes} digest - The mix digest (256 bits)\n * @callback callback\n * @param {error} err - Error object\n * @param {Boolean} result - returns true if the provided solution is valid, otherwise false.\n */\nGethApiDouble.prototype.eth_submitWork = function(nonce, powHash, digest, callback) {\n  callback(null, false);\n};\n\n/**\n * Used for submitting mining hashrate.\n *\n * @param {String} hashRate - a hexadecimal string representation (32 bytes) of the hash rate\n * @param {String} clientID - A random hexadecimal(32 bytes) ID identifying the client\n * @callback callback\n * @param {error} err - Error object\n * @param {Boolean} result - returns true if submitting went through succesfully and false otherwise.\n */\nGethApiDouble.prototype.eth_submitHashrate = function(hashRate, clientID, callback) {\n  callback(null, false);\n};\n\n/**\n * Stores a string in the local database.\n *\n * @param {String} dbName - Database name.\n * @param {String} key - Key name.\n * @param {String} value - String to store.\n * @callback callback\n * @param {error} err - Error object\n * @param {Boolean} result - returns true if the value was stored, otherwise false.\n */\nGethApiDouble.prototype.db_putString = function(dbName, key, value, callback) {\n  callback(null, false);\n};\n\n/**\n * Returns string from the local database\n *\n * @param {String} dbName - Database name.\n * @param {String} key - Key name.\n * @callback callback\n * @param {error} - Error Object\n * @param {String} result - The previously stored string.\n */\nGethApiDouble.prototype.db_getString = function(dbName, key, callback) {\n  callback(null, \"\");\n};\n\n/**\n * Stores binary data in the local database.\n *\n * @param {String} dbName - Database name.\n * @param {String} key - Key name.\n * @param {DATA} data - Data to store.\n * @callback callback\n * @param {error} err - Error Object\n * @param {Boolean} result - returns true if the value was stored, otherwise false.\n */\nGethApiDouble.prototype.db_putHex = function(dbName, key, data, callback) {\n  callback(null, false);\n};\n\n/**\n * Returns binary data from the local database\n *\n * @param {String} dbName - Database name.\n * @param {String} key - Key name.\n * @callback callback\n * @param {error} err - Error Object\n * @param {DATA} result - The previously stored data.\n */\nGethApiDouble.prototype.db_getHex = function(dbName, key, callback) {\n  callback(null, \"0x00\");\n};\n\n/**\n * Sends a whisper message.\n *\n * @param {DATA, 60 Bytes} from - (optional) The identity of the sender.\n * @param {DATA, 60 Bytes} to -\n *  ^(optional) The identity of the receiver. When present whisper will encrypt the message so that\n *  only the receiver can decrypt it.\n * @param {Array of DATA} topics - Array of DATA topics, for the receiver to identify messages.\n * @param {DATA} payload - The payload of the message.\n * @param {QUANTITY} priority - The integer of the priority in a range from ... (?).\n * @param {QUANTITY} ttl - integer of the time to live in seconds.\n * @callback callback\n * @param {error} err - Error Object\n * @param {Boolean} result - returns true if the message was sent, otherwise false.\n */\nGethApiDouble.prototype.shh_post = function(from, to, topics, payload, priority, ttl, callback) {\n  callback(null, false);\n};\n\n/**\n * Creates new whisper identity in the client.\n *\n * @callback callback\n * @param {error} err - Error Object\n * @param {DATA, 60 Bytes} result - the address of the new identiy.\n */\nGethApiDouble.prototype.shh_newIdentity = function(callback) {\n  callback(null, \"0x00\");\n};\n\n/**\n * Checks if the client hold the private keys for a given identity.\n *\n * @param {DATA, 60 Bytes} address - The identity address to check.\n * @callback callback\n * @param {error} err - Error Object\n * @param {Boolean} result - returns true if the client holds the privatekey for that identity, otherwise false.\n */\nGethApiDouble.prototype.shh_hasIdentity = function(address, callback) {\n  callback(null, false);\n};\n\n/**\n * Creates a new group.\n *\n * @callback callback\n * @param {error} err - Error Object\n * @param {DATA, 60 Bytes} result - the address of the new group.\n */\nGethApiDouble.prototype.shh_newGroup = function(callback) {\n  callback(null, \"0x00\");\n};\n\n/**\n * Adds a whisper identity to the group\n *\n * @param {DATA, 60 Bytes} - The identity address to add to a group.\n * @callback callback\n * @param {error} err - Error Object\n * @param {Boolean} result - returns true if the identity was successfully added to the group, otherwise false.\n */\nGethApiDouble.prototype.shh_addToGroup = function(address, callback) {\n  callback(null, false);\n};\n\n/**\n * Creates filter to notify, when client receives whisper message matching the filter options.\n *\n * @param {DATA, 60 Bytes} to -\n * ^(optional) Identity of the receiver. When present it will try to decrypt any incoming message\n *  if the client holds the private key to this identity.\n * @param {Array of DATA} topics - Array of DATA topics which the incoming message's topics should match.\n * @callback callback\n * @param {error} err - Error Object\n * @param {Boolean} result - returns true if the identity was successfully added to the group, otherwise false.\n */\nGethApiDouble.prototype.shh_newFilter = function(to, topics, callback) {\n  callback(null, false);\n};\n\n/**\n * Uninstalls a filter with given id. Should always be called when watch is no longer needed.\n * Additonally Filters timeout when they aren't requested with shh_getFilterChanges for a period of time.\n *\n * @param {QUANTITY} id - The filter id. Ex: \"0x7\"\n * @callback callback\n * @param {error} err - Error Object\n * @param {Boolean} result - true if the filter was successfully uninstalled, otherwise false.\n */\nGethApiDouble.prototype.shh_uninstallFilter = function(id, callback) {\n  callback(null, false);\n};\n\n/**\n * Polling method for whisper filters. Returns new messages since the last call of this method.\n *\n * @param {QUANTITY} id - The filter id. Ex: \"0x7\"\n * @callback callback\n * @param {error} err - Error Object\n * @param {Array} result - More Info: https://github.com/ethereum/wiki/wiki/JSON-RPC#shh_getfilterchanges\n */\nGethApiDouble.prototype.shh_getFilterChanges = function(id, callback) {\n  callback(null, []);\n};\n\n/**\n * Get all messages matching a filter. Unlike shh_getFilterChanges this returns all messages.\n *\n * @param {QUANTITY} id - The filter id. Ex: \"0x7\"\n * @callback callback\n * @param {error} err - Error Object\n * @param {Array} result - See: shh_getFilterChanges\n */\nGethApiDouble.prototype.shh_getMessages = function(id, callback) {\n  callback(null, false);\n};\n\nmodule.exports = GethApiDouble;\n","var Account = require(\"ethereumjs-account\");\nvar RuntimeError = require(\"./utils/runtimeerror\");\nvar Transaction = require(\"./utils/transaction\");\nvar utils = require(\"ethereumjs-util\");\nvar seedrandom = require(\"seedrandom\");\nvar bip39 = require(\"bip39\");\nvar wallet = require(\"ethereumjs-wallet\");\nvar hdkey = require(\"ethereumjs-wallet/hdkey\");\nvar async = require(\"async\");\nvar BlockchainDouble = require(\"./blockchain_double.js\");\nvar ForkedBlockchain = require(\"./utils/forkedblockchain.js\");\nvar Web3 = require(\"web3\");\nvar sigUtil = require(\"eth-sig-util\");\nvar _ = require(\"lodash\");\nconst { BlockOutOfRangeError } = require(\"./utils/errorhelper\");\nconst BN = require(\"bn.js\");\n\nconst ZERO_BUFFER = Buffer.from([0]);\n\nvar to = require(\"./utils/to\");\nvar random = require(\"./utils/random\");\nvar TXRejectedError = require(\"./utils/txrejectederror\");\n\nfunction StateManager(options, provider) {\n  this.options = options = this._applyDefaultOptions(options || {});\n\n  if (options.fork) {\n    this.blockchain = new ForkedBlockchain(options);\n  } else {\n    this.blockchain = new BlockchainDouble(options);\n  }\n\n  this.vm = this.blockchain.vm;\n  this.stateTrie = this.blockchain.stateTrie;\n\n  this.accounts = {};\n  this.secure = !!options.secure;\n  this.account_passwords = {};\n  this.personal_accounts = {};\n  this.total_accounts = options.total_accounts;\n  this.coinbase = null;\n\n  this.latest_filter_id = 1;\n\n  // This queue manages actions that shouldn't be run in parallel.\n  // The action_processing flag ensures new actions are queued instead of\n  // run immediately.\n  this.action_queue = [];\n  this.action_processing = false;\n\n  this.snapshots = [];\n  this.logger = options.logger;\n  this.net_version = options.network_id;\n  this.mnemonic = options.mnemonic;\n  this.wallet = hdkey.fromMasterSeed(bip39.mnemonicToSeed(this.mnemonic));\n  this.wallet_hdpath = options.hdPath;\n\n  this.gasPriceVal = to.rpcQuantityHexString(options.gasPrice);\n\n  this.is_mining = true;\n  this.blockTime = options.blockTime;\n  this.is_mining_on_interval = !!options.blockTime;\n  this.mining_interval_timeout = null;\n\n  this._provider = provider;\n}\n\nconst defaultOptions = {\n  total_accounts: 10,\n  gasPrice: \"0x77359400\", // 2 gwei\n  default_balance_ether: 100,\n  unlocked_accounts: [],\n  hdPath: \"m/44'/60'/0'/0/\"\n};\n\nStateManager.prototype._applyDefaultOptions = function(options) {\n  // do this so that we can use the same seed on our next run and get the same\n  // results without explicitly setting a seed up front\n  if (!options.seed) {\n    options.seed = random.randomAlphaNumericString(10, seedrandom());\n  }\n\n  // generate a randomized default mnemonic\n  if (!options.mnemonic) {\n    let randomBytes = random.randomBytes(16, seedrandom(options.seed));\n    options.mnemonic = bip39.entropyToMnemonic(randomBytes.toString(\"hex\"));\n  }\n\n  if (!options.fork && !options.network_id) {\n    options.network_id = new Date().getTime();\n  }\n\n  // We want this function to mutate the options object so that we can report\n  // our settings back to our consumer application (e.g., ganache)\n  return _.merge(options, defaultOptions, Object.assign({}, options));\n};\n\nStateManager.prototype.initialize = function(callback) {\n  var self = this;\n\n  var accounts = [];\n\n  let defaultBalanceWei = to.hex(Web3.utils.toWei(self.options.default_balance_ether.toString(), \"ether\"));\n\n  if (self.options.accounts) {\n    accounts = self.options.accounts.map(self.createAccount.bind(self));\n  } else {\n    if (!self.total_accounts) {\n      return callback(\n        new Error(\"Cannot initialize chain: either options.accounts or options.total_accounts must be specified\")\n      );\n    }\n\n    for (var i = 0; i < self.total_accounts; i++) {\n      accounts.push(\n        self.createAccount({\n          index: i,\n          balance: defaultBalanceWei\n        })\n      );\n    }\n  }\n\n  self.coinbase = to.hex(accounts[0].address);\n  self.accounts = {};\n\n  accounts.forEach(function(data) {\n    self.accounts[data.address] = data;\n    self.personal_accounts[data.address.toLowerCase()] = true;\n  });\n\n  // Turn array into object, mostly for speed purposes.\n  // No need for caller to specify private keys.\n  self.unlocked_accounts = self.options.unlocked_accounts.reduce(function(obj, address) {\n    // If it doesn't have a hex prefix, must be a number (either a string or number type).\n    if ((address + \"\").indexOf(\"0x\") !== 0) {\n      let idx = parseInt(address);\n      let account = accounts[idx];\n      if (!account) {\n        throw new Error(`Account at index ${idx} not found. Max index available is ${accounts.length - 1}.`);\n      }\n      address = account.address.toLowerCase();\n    }\n\n    obj[address.toLowerCase()] = true; // can be any value\n    return obj;\n  }, {});\n\n  if (!self.secure) {\n    accounts.forEach(function(data) {\n      self.unlocked_accounts[data.address.toLowerCase()] = data;\n    });\n  }\n\n  self.blockchain.initialize(accounts, function(err) {\n    if (err) {\n      return callback(err);\n    }\n\n    // If the user didn't pass a specific version id in, then use the\n    // forked blockchain's version (if it exists) or create our own.\n    if (!self.net_version) {\n      self.net_version = self.blockchain.forkVersion;\n    }\n\n    if (self.is_mining_on_interval) {\n      self.mineOnInterval();\n    }\n\n    callback();\n  });\n};\n\nStateManager.prototype._minerCancellationToken = null;\nStateManager.prototype.mineOnInterval = function() {\n  // cancel the a previous miner's timeout\n  clearTimeout(this.mining_interval_timeout);\n\n  // make sure a pending eth_mine doesn't come back and execute mineOnInterval\n  // again...\n  if (this._minerCancellationToken !== null) {\n    this._minerCancellationToken.cancelled = true;\n  }\n\n  // if mining was stopped `mineOnInterval` shouldn't start mining again\n  if (!this.is_mining) {\n    this.logger.log(\"Warning: mineOnInterval called when miner was stopped\");\n    return;\n  }\n\n  const cancellationToken = { cancelled: false };\n  this._minerCancellationToken = cancellationToken;\n\n  const timeout = (this.mining_interval_timeout = setTimeout(\n    this._provider.send.bind(this._provider),\n    this.blockTime * 1000,\n    { method: \"evm_mine\" },\n    () => {\n      if (!cancellationToken.cancelled) {\n        this.mineOnInterval.bind(this)();\n      }\n    }\n  ));\n\n  // Ensure this won't keep a node process open.\n  if (typeof timeout.unref === \"function\") {\n    timeout.unref();\n  }\n};\n\nStateManager.prototype.createAccount = function(opts, i) {\n  var secretKey;\n\n  if (opts.generate) {\n    secretKey = wallet.generate().getPrivateKey();\n  } else if (opts.secretKey) {\n    secretKey = utils.toBuffer(to.hex(opts.secretKey));\n  } else {\n    var index = typeof opts.index === \"undefined\" ? i : opts.index;\n    var acct = this.wallet.derivePath(this.wallet_hdpath + index); // index is a number\n    secretKey = acct.getWallet().getPrivateKey(); // Buffer\n  }\n\n  var publicKey = utils.privateToPublic(secretKey);\n  var address = utils.publicToAddress(publicKey);\n\n  var account = new Account();\n\n  account.balance = to.hex(opts.balance);\n\n  var data = {\n    secretKey: secretKey,\n    publicKey: publicKey,\n    address: to.hex(address).toLowerCase(),\n    account: account\n  };\n\n  return data;\n};\n\nStateManager.prototype.blockNumber = function(callback) {\n  return this.blockchain.getHeight(callback);\n};\n\nStateManager.prototype.gasPrice = function() {\n  return this.gasPriceVal;\n};\n\nStateManager.prototype.getBalance = function(address, number, callback) {\n  this.blockchain.getBalance(address, number, function(err, balance) {\n    if (balance) {\n      balance = to.rpcQuantityHexString(balance);\n    }\n    callback(err, balance);\n  });\n};\n\nStateManager.prototype.getTransactionCount = function(address, number, callback) {\n  this.blockchain.getNonce(address, number, function(err, nonce) {\n    if (nonce) {\n      nonce = to.rpcQuantityHexString(nonce);\n    }\n    callback(err, nonce);\n  });\n};\n\nStateManager.prototype.getCode = function(address, number, callback) {\n  this.blockchain.getCode(address, number, function(err, code) {\n    if (code) {\n      code = to.hex(code);\n    }\n    callback(err, code);\n  });\n};\n\nStateManager.prototype.queueRawTransaction = function(data, callback) {\n  const tx = new Transaction(data, Transaction.types.signed);\n  // use toLowerCase() to properly handle from addresses meant to be validated.\n  const from = to.hex(tx.from).toLowerCase();\n  this._queueTransaction(\"eth_sendRawTransaction\", tx, from, null, callback);\n};\n\nStateManager.prototype.queueStorage = function(address, position, block, callback) {\n  this.action_queue.push({\n    method: \"eth_getStorageAt\",\n    address: utils.addHexPrefix(address),\n    position: utils.addHexPrefix(position),\n    block: block,\n    callback: callback\n  });\n\n  // We know there's work, so get started.\n  this.processNextAction();\n};\n\nStateManager.prototype.queueTransaction = function(method, txJsonRpc, blockNumber, callback) {\n  // use toLowerCase() to properly handle from addresses meant to be validated.\n  const from = txJsonRpc.from ? to.hex(txJsonRpc.from).toLowerCase() : null;\n\n  if (from == null) {\n    callback(new TXRejectedError(\"from not found; is required\"));\n    return;\n  }\n\n  // Error checks. It's possible to JSON.stringify a Buffer to JSON.\n  // we actually now handle this \"properly\" (not sure about spec), but for\n  // legacy reasons we don't allow it.\n  if (txJsonRpc.to && typeof txJsonRpc.to !== \"string\") {\n    return callback(new TXRejectedError(\"Invalid to address\"));\n  }\n\n  const isKnownAccount = this.accounts.hasOwnProperty(from);\n\n  if (method === \"eth_sendTransaction\" && !this.unlocked_accounts.hasOwnProperty(from)) {\n    const msg = isKnownAccount ? \"signer account is locked\" : \"sender account not recognized\";\n    return callback(new TXRejectedError(msg));\n  }\n\n  let type = Transaction.types.none;\n  if (!isKnownAccount || method === \"eth_call\") {\n    type |= Transaction.types.fake;\n  }\n\n  let tx;\n  try {\n    tx = Transaction.fromJSON(txJsonRpc, type);\n    this._setTransactionDefaults(tx);\n  } catch (e) {\n    callback(e);\n    return;\n  }\n  this._queueTransaction(method, tx, from, blockNumber, callback);\n};\n\nStateManager.prototype._setTransactionDefaults = function(tx) {\n  if (tx.gasLimit.length === 0) {\n    tx.gasLimit = utils.toBuffer(this.blockchain.defaultTransactionGasLimit);\n  }\n\n  if (tx.gasPrice.length === 0) {\n    tx.gasPrice = utils.toBuffer(this.gasPriceVal);\n  }\n\n  if (tx.value.length === 0) {\n    tx.value = Buffer.from([0]);\n  }\n\n  if (tx.to.length === 0 || tx.to.equals(ZERO_BUFFER)) {\n    tx.to = Buffer.allocUnsafe(0);\n  }\n};\n\nStateManager.prototype._queueTransaction = function(method, tx, from, blockNumber, callback) {\n  if (!(tx instanceof Transaction)) {\n    throw new TXRejectedError(\"tx must be of type Transaction\");\n  }\n\n  // If the transaction has a higher gas limit than the block gas limit, error.\n  if (to.number(tx.gasLimit) > to.number(this.blockchain.blockGasLimit)) {\n    return callback(new TXRejectedError(\"Exceeds block gas limit\"));\n  }\n\n  this.action_queue.push({\n    method,\n    from,\n    tx,\n    callback,\n    blockNumber\n  });\n\n  // We know there's work, so get started.\n  this.processNextAction();\n};\n\nStateManager.prototype.queueTransactionTrace = function(txHash, params, callback) {\n  this.action_queue.push({\n    method: \"debug_traceTransaction\",\n    hash: to.hex(txHash),\n    params: params,\n    callback: callback\n  });\n\n  // We know there's work, so get started.\n  this.processNextAction();\n};\n\nStateManager.prototype.processNextAction = function(override) {\n  var self = this;\n\n  if (override !== true) {\n    if (this.action_processing === true || this.action_queue.length === 0) {\n      return;\n    }\n  }\n\n  var queued = this.action_queue.shift();\n\n  // Set the flag that we're currently processing something.\n  this.action_processing = true;\n\n  var intermediary = function(err, result) {\n    queued.callback(err, result);\n\n    if (self.action_queue.length > 0) {\n      self.processNextAction(true);\n    } else {\n      self.action_processing = false;\n    }\n  };\n\n  if (typeof queued.method === \"function\") {\n    var result = queued.method();\n    return intermediary(null, result);\n  } else if (queued.method === \"eth_getStorageAt\") {\n    this.blockchain.getStorage(queued.address, queued.position, queued.block, function(err, result) {\n      if (err) {\n        return intermediary(err);\n      }\n\n      if (result) {\n        result = utils.rlp.decode(result);\n      }\n\n      result = to.hex(result || 0);\n      intermediary(null, result);\n    });\n  } else if (queued.method === \"debug_traceTransaction\") {\n    this.blockchain.processTransactionTrace(queued.hash, queued.params, intermediary);\n  } else if (queued.method === \"eth_sendTransaction\" || queued.method === \"eth_sendRawTransaction\") {\n    this.processTransaction(queued.from, queued.tx, intermediary);\n  } else if (queued.method === \"eth_call\") {\n    this.processCall(queued.from, queued.tx, queued.blockNumber, intermediary);\n  } else if (queued.method === \"eth_estimateGas\") {\n    this.processGasEstimate(queued.from, queued.tx, queued.blockNumber, intermediary);\n  }\n};\n\nStateManager.prototype.sign = function(address, dataToSign) {\n  var account = this.accounts[to.hex(address).toLowerCase()];\n\n  if (!account) {\n    throw new Error(\"cannot sign data; no private key\");\n  }\n\n  var secretKey = account.secretKey;\n  var msg = to.buffer(dataToSign, \"hex\");\n  var msgHash = utils.hashPersonalMessage(msg);\n  var sgn = utils.ecsign(msgHash, Buffer.from(secretKey));\n  return utils.toRpcSig(sgn.v, sgn.r, sgn.s);\n};\n\nStateManager.prototype.signTypedData = function(address, typedDataToSign) {\n  var account = this.accounts[to.hex(address).toLowerCase()];\n  if (!account) {\n    throw new Error(\"cannot sign data; no private key\");\n  }\n\n  if (!typedDataToSign.types) {\n    throw new Error(\"cannot sign data; types missing\");\n  }\n\n  if (!typedDataToSign.types.EIP712Domain) {\n    throw new Error(\"cannot sign data; EIP712Domain definition missing\");\n  }\n\n  if (!typedDataToSign.domain) {\n    throw new Error(\"cannot sign data; domain missing\");\n  }\n\n  if (!typedDataToSign.primaryType) {\n    throw new Error(\"cannot sign data; primaryType missing\");\n  }\n\n  if (!typedDataToSign.message) {\n    throw new Error(\"cannot sign data; message missing\");\n  }\n\n  return sigUtil.signTypedData(account.secretKey, { data: typedDataToSign });\n};\n\nStateManager.prototype.printTransactionReceipt = function(txHash, error, callback) {\n  var self = this;\n\n  self.blockchain.getTransactionReceipt(txHash, function(err, receipt) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.blockchain.latestBlock(function(err, block) {\n      if (err) {\n        return callback(err);\n      }\n\n      receipt = receipt.toJSON();\n\n      self.logger.log(\"\");\n      self.logger.log(\"  Transaction: \" + txHash);\n\n      if (receipt.contractAddress != null) {\n        self.logger.log(\"  Contract created: \" + receipt.contractAddress);\n      }\n\n      self.logger.log(\"  Gas usage: \" + parseInt(receipt.gasUsed, 16));\n      self.logger.log(\"  Block Number: \" + parseInt(receipt.blockNumber, 16));\n      self.logger.log(\"  Block Time: \" + new Date(to.number(block.header.timestamp) * 1000).toString());\n\n      if (error) {\n        self.logger.log(\"  Runtime Error: \" + error.error);\n        if (error.reason) {\n          self.logger.log(\"  Revert reason: \" + error.reason);\n        }\n      }\n\n      self.logger.log(\"\");\n\n      callback(null, txHash);\n    });\n  });\n};\n\nStateManager.prototype.processBlock = function(timestamp, callback) {\n  var self = this;\n\n  if (typeof timestamp === \"function\") {\n    callback = timestamp;\n    timestamp = null;\n  }\n\n  self.blockchain.processNextBlock(timestamp, function(runtimeError, transactions, vmOutput) {\n    if (runtimeError && runtimeError instanceof RuntimeError === false) {\n      // This is bad. Get out.\n      return callback(runtimeError, transactions, vmOutput);\n    }\n\n    // TODO: Can we refactor printTransactionReceipt so it's synchronous?\n    // We technically have the raw vm receipts (though they're not full receipts here...).\n    async.eachSeries(\n      transactions,\n      function(tx, finishedPrinting) {\n        var hash = to.hex(tx.hash());\n        var error = runtimeError == null ? { results: {} } : runtimeError;\n        self.printTransactionReceipt(hash, error.results[hash], finishedPrinting);\n      },\n      callback(runtimeError, transactions, vmOutput)\n    );\n  });\n};\n\nStateManager.prototype.processBlocks = function(totalBlocks, callback) {\n  var self = this;\n\n  if (typeof totalBlocks === \"function\") {\n    callback = totalBlocks;\n    totalBlocks = null;\n  }\n\n  // Note: VM errors (errors that the VM directly returns) trump all runtime errors.\n  var runtimeError = null;\n  var amountProcessed = 0;\n\n  async.whilst(\n    function() {\n      var shouldContinue;\n\n      if (totalBlocks == null) {\n        shouldContinue = self.blockchain.pending_transactions.length > 0;\n      } else {\n        shouldContinue = amountProcessed < totalBlocks;\n      }\n\n      return shouldContinue;\n    },\n    function(done) {\n      self.processBlock(function(err, transactions, vmOutput) {\n        amountProcessed += 1;\n\n        if (err) {\n          if (err instanceof RuntimeError === false) {\n            // This is bad. Get out.\n            return done(err);\n          }\n\n          // We must have a RuntimeError. Merge results if we've found\n          // other runtime errors during this execution.\n          if (runtimeError == null) {\n            runtimeError = err;\n          } else {\n            runtimeError.combine(err);\n          }\n        }\n\n        // Note we don't quit on runtime errors. We keep processing transactions.\n        done();\n      });\n    },\n    function(err) {\n      // Remember: vm errors trump runtime errors\n      callback(err || runtimeError);\n    }\n  );\n};\n\nStateManager.prototype.processCall = function(from, tx, blockNumber, callback) {\n  var self = this;\n\n  self.createTransactionWithCorrectNonce(tx, from, function(err, tx) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.blockchain.processCall(tx, blockNumber, function(err, results) {\n      if (err) {\n        if (err instanceof BlockOutOfRangeError) {\n          // block doesn't exist\n          return callback(null, null);\n        }\n        return callback(err);\n      }\n\n      var result = \"0x\";\n      if (!results.error && results.vm.return) {\n        result = to.hex(results.vm.return);\n      } else if (results.error) {\n        self.logger.log(`Error processing call: ${results.error}`);\n      }\n\n      return callback(null, result);\n    });\n  });\n};\n\nStateManager.prototype.processGasEstimate = function(from, tx, blockNumber, callback) {\n  var self = this;\n\n  self.createTransactionWithCorrectNonce(tx, from, function(err, tx) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.blockchain.estimateGas(tx, blockNumber, function(err, results) {\n      if (err) {\n        return callback(err);\n      }\n      var result = \"0x\";\n      if (!results.error) {\n        result = results.gasRefund ? to.hex(results.gasEstimate.add(results.gasRefund)) : to.hex(results.gasEstimate);\n      } else {\n        self.logger.log(`Error calculating gas estimate: ${results.error}`);\n      }\n      return callback(null, result);\n    });\n  });\n};\n\nStateManager.prototype.processTransaction = function(from, tx, callback) {\n  var self = this;\n\n  self.createTransactionWithCorrectNonce(tx, from, function(err, tx) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.blockchain.queueTransaction(tx);\n\n    var txHash = to.hex(tx.hash());\n\n    // If we're not currently mining or we're mining on an interval,\n    // only queue the transaction, don't process it.\n    if (self.is_mining === false || self.is_mining_on_interval) {\n      return callback(null, txHash);\n    }\n\n    self.processBlocks(function(err) {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, txHash);\n    });\n  });\n};\n\nStateManager.prototype.getTransactionReceipt = function(hash, callback) {\n  this.blockchain.getTransactionReceipt(hash, function(err, receipt) {\n    if (err && err.notFound) {\n      // Return null if the receipt's not found.\n      return callback(null, null);\n    }\n    callback(err, receipt);\n  });\n};\n\nStateManager.prototype.getBlock = function(hashOrNumber, callback) {\n  this.blockchain.getBlock(hashOrNumber, callback);\n};\n\nStateManager.prototype.getLogs = function(filter, callback) {\n  var self = this;\n\n  // filter.address may be a single address or an array\n  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getlogs\n  var expectedAddress = filter.address && (Array.isArray(filter.address) ? filter.address : [filter.address]);\n  expectedAddress =\n    expectedAddress &&\n    expectedAddress.map(function(a) {\n      return a.toLowerCase();\n    });\n  var expectedTopics = filter.topics || [];\n\n  async.parallel(\n    {\n      fromBlock: this.blockchain.getEffectiveBlockNumber.bind(this.blockchain, filter.fromBlock || \"latest\"),\n      toBlock: this.blockchain.getEffectiveBlockNumber.bind(this.blockchain, filter.toBlock || \"latest\"),\n      latestBlock: this.blockchain.getEffectiveBlockNumber.bind(this.blockchain, \"latest\")\n    },\n    function(err, results) {\n      if (err) {\n        return callback(err);\n      }\n      var fromBlock = results.fromBlock;\n      var toBlock = results.toBlock;\n      var latestBlock = results.latestBlock;\n\n      if (toBlock > latestBlock) {\n        toBlock = latestBlock;\n      }\n\n      var logs = [];\n      var current = fromBlock;\n\n      async.whilst(\n        function() {\n          return current <= toBlock;\n        },\n        function(finished) {\n          self.blockchain.getBlockLogs(current, function(err, blockLogs) {\n            if (err) {\n              return finished(err);\n            }\n\n            // Filter logs that match the address\n            var filtered = !expectedAddress\n              ? blockLogs\n              : blockLogs.filter(function(log) {\n                return expectedAddress.indexOf(log.address.toLowerCase()) > -1;\n              });\n\n            // Now filter based on topics.\n            filtered = filtered.filter(function(log) {\n              var keep = true;\n              for (var i = 0; i < expectedTopics.length; i++) {\n                var expectedTopic = expectedTopics[i];\n                var logTopic = log.topics[i];\n                if (expectedTopic == null) {\n                  continue;\n                }\n                var isMatch = Array.isArray(expectedTopic)\n                  ? expectedTopic.includes(logTopic)\n                  : expectedTopic === logTopic;\n                if (i >= log.topics.length || !isMatch) {\n                  keep = false;\n                  break;\n                }\n              }\n              return keep;\n            });\n\n            logs.push.apply(logs, filtered);\n\n            current += 1;\n            finished();\n          });\n        },\n        function(err) {\n          if (err) {\n            return callback(err);\n          }\n\n          logs = logs.map(function(log) {\n            return log.toJSON();\n          });\n\n          callback(err, logs);\n        }\n      );\n    }\n  );\n};\n\n// Note: Snapshots have 1-based ids.\nStateManager.prototype.snapshot = function(callback) {\n  var self = this;\n\n  this.blockchain.getHeight(function(err, blockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.snapshots.push({\n      blockNumber: blockNumber,\n      timeAdjustment: self.blockchain.timeAdjustment\n    });\n\n    self.logger.log(\"Saved snapshot #\" + self.snapshots.length);\n\n    callback(null, to.hex(self.snapshots.length));\n  });\n};\n\nStateManager.prototype.revert = function(snapshotId, callback) {\n  var self = this;\n\n  // Convert from hex.\n  snapshotId = utils.bufferToInt(snapshotId);\n\n  this.logger.log(\"Reverting to snapshot #\" + snapshotId);\n\n  if (snapshotId > this.snapshots.length) {\n    // the snapshot doesn't exist now, or it has already been reverted\n    callback(null, false);\n    return false;\n  }\n\n  // Convert to zero based.\n  snapshotId = snapshotId - 1;\n  var timeAdjustment = this.snapshots[snapshotId].timeAdjustment;\n\n  // Loop through each snapshot with a higher id than the current one.\n  async.whilst(\n    function() {\n      return self.snapshots.length > snapshotId;\n    },\n    function(nextSnapshot) {\n      var snapshot = self.snapshots.pop();\n\n      // For each snapshot, asynchronously pop off the blocks it represents.\n      async.during(\n        function(doneWithTest) {\n          self.blockchain.getHeight(function(err, blockNumber) {\n            if (err) {\n              return doneWithTest(err);\n            }\n\n            doneWithTest(null, blockNumber > snapshot.blockNumber);\n          });\n        },\n        function(nextBlock) {\n          self.blockchain.popBlock(function(err) {\n            if (err) {\n              return nextBlock(err);\n            }\n            nextBlock();\n          });\n        },\n        nextSnapshot\n      );\n    },\n    function(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      // Pending transactions are removed when you revert.\n      self.blockchain.clearPendingTransactions();\n      // The time adjustment is restored to its prior state\n      self.blockchain.timeAdjustment = timeAdjustment;\n\n      callback(null, true);\n    }\n  );\n};\n\nStateManager.prototype.hasContractCode = function(address, callback) {\n  this.vm.stateManager.getContractCode(address, function(err, result) {\n    if (err != null) {\n      callback(err, false);\n    } else {\n      callback(null, true);\n    }\n  });\n};\n\nStateManager.prototype.startMining = function(callback) {\n  if (this.is_mining) {\n    process.nextTick(callback);\n    this.logger.log(\"Warning: startMining called when miner was already started\");\n    return;\n  }\n\n  this.is_mining = true;\n\n  if (this.is_mining_on_interval) {\n    this.mineOnInterval();\n    process.nextTick(callback);\n  } else {\n    this.processBlocks(callback);\n  }\n};\n\nStateManager.prototype.stopMining = function(callback) {\n  if (this.is_mining) {\n    if (this._minerCancellationToken) {\n      this._minerCancellationToken.cancelled = true;\n      this._minerCancellationToken = null;\n    }\n    this.is_mining = false;\n    clearTimeout(this.mining_interval_timeout);\n    this.mining_interval_timeout = null;\n  } else {\n    this.logger.log(\"Warning: stopMining called when miner was already stopped\");\n  }\n  callback && process.nextTick(callback);\n};\n\nStateManager.prototype.isUnlocked = function(address) {\n  return this.unlocked_accounts[address.toLowerCase()] != null;\n};\n\nStateManager.prototype.createTransactionWithCorrectNonce = function(tx, from, callback) {\n  // account for transactions waiting in the tx queue\n  this.blockchain.getQueuedNonce(from, (err, expectedNonce) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const validateNonce = (tx, expectedNonce) => {\n      if (tx.validateNonce(expectedNonce)) {\n        return Promise.resolve(tx);\n      } else {\n        const expected = new BN(expectedNonce).toString(10);\n        const actual = new BN(tx.nonce).toString(10);\n        return Promise.reject(\n          new TXRejectedError(\n            `the tx doesn't have the correct nonce. account has nonce of: ${expected} tx has nonce of: ${actual}`\n          )\n        );\n      }\n    };\n    const done = (tx) => callback(null, tx);\n\n    if (tx.isSigned()) {\n      validateNonce(tx, expectedNonce)\n        .then(done)\n        .catch(callback);\n    } else {\n      const sign = (tx) => {\n        // we need to sign transactions if they haven't been signed already\n        // but we never sign fake transactions\n        if (!tx.isFake() && !tx.isSigned()) {\n          const account = this.accounts[from];\n          if (account) {\n            tx.sign(account.secretKey);\n          }\n        }\n        return Promise.resolve(tx);\n      };\n\n      // Validate the tx's nonce and then sign the transaction.\n      // By signing this transaction now we ensure all future calls to tx.hash()\n      // return the same signed transaction hash. It's sort of an unintuitive\n      // quirk of etheremjs-tx that:\n      //   tx.hash(includeSignature);\n      //   tx.sign(secretKey);\n      //   tx.hash(includeSignature);\n      // will produce different hashes.\n      if (tx.nonce.length === 0) {\n        // Since this transaction is unsigned and the nonce was not defined\n        // we can go ahead and change the nonce and not worry about\n        // invalidating the tx hash the client may be expecting (automatic nonce\n        // calculation should have been expected by the client in this case).\n        tx.nonce = expectedNonce;\n        sign(tx).then(done);\n      } else {\n        validateNonce(tx, expectedNonce)\n          .then(sign)\n          .then(done)\n          .catch(callback);\n      }\n    }\n  });\n};\nmodule.exports = StateManager;\n","module.exports = require(\"ethereumjs-abi\");","module.exports = require(\"ethereumjs-tx\");","module.exports = require(\"ethereumjs-tx/fake\");","module.exports = require(\"assert\");","module.exports = require(\"rlp\");","module.exports = require(\"seedrandom\");","module.exports = require(\"bip39\");","module.exports = require(\"safe-buffer\");","module.exports = require(\"crypto\");","module.exports = require(\"scrypt.js\");","module.exports = require(\"uuid/v4\");","module.exports = require(\"bs58check\");","'use strict';\n\nvar HDKey = require('hdkey');\nvar Wallet = require('./index.js');\n\nfunction EthereumHDKey() {}\n\n/*\n * Horrible wrapping.\n */\nfunction fromHDKey(hdkey) {\n  var ret = new EthereumHDKey();\n  ret._hdkey = hdkey;\n  return ret;\n}\n\nEthereumHDKey.fromMasterSeed = function (seedBuffer) {\n  return fromHDKey(HDKey.fromMasterSeed(seedBuffer));\n};\n\nEthereumHDKey.fromExtendedKey = function (base58key) {\n  return fromHDKey(HDKey.fromExtendedKey(base58key));\n};\n\nEthereumHDKey.prototype.privateExtendedKey = function () {\n  if (!this._hdkey.privateExtendedKey) {\n    throw new Error('This is a public key only wallet');\n  }\n  return this._hdkey.privateExtendedKey;\n};\n\nEthereumHDKey.prototype.publicExtendedKey = function () {\n  return this._hdkey.publicExtendedKey;\n};\n\nEthereumHDKey.prototype.derivePath = function (path) {\n  return fromHDKey(this._hdkey.derive(path));\n};\n\nEthereumHDKey.prototype.deriveChild = function (index) {\n  return fromHDKey(this._hdkey.deriveChild(index));\n};\n\nEthereumHDKey.prototype.getWallet = function () {\n  if (this._hdkey._privateKey) {\n    return Wallet.fromPrivateKey(this._hdkey._privateKey);\n  } else {\n    return Wallet.fromPublicKey(this._hdkey._publicKey, true);\n  }\n};\n\nmodule.exports = EthereumHDKey;","module.exports = require(\"hdkey\");","module.exports = require(\"ethereumjs-vm\");","module.exports = require(\"heap\");","var LevelUpArrayAdapter = require(\"./database/leveluparrayadapter\");\nvar LevelUpObjectAdapter = require(\"./database/levelupobjectadapter\");\nvar levelup = require(\"levelup\");\nvar encode = require(\"encoding-down\");\nvar filedown = require(\"./database/filedown\");\nvar cachedown = require(\"cachedown\");\nvar txserializer = require(\"./database/txserializer\");\nvar blockserializer = require(\"./database/blockserializer\");\nvar bufferserializer = require(\"./database/bufferserializer\");\nvar BlockLogsSerializer = require(\"./database/blocklogsserializer\");\nvar ReceiptSerializer = require(\"./database/receiptserializer\");\nvar tmp = require(\"tmp\");\n\nfunction Database(options) {\n  this.options = options;\n  this.directory = null;\n}\n\nDatabase.prototype.initialize = function(callback) {\n  var self = this;\n\n  function getDir(cb) {\n    if (self.options.db_path) {\n      cb(null, self.options.db_path);\n    } else {\n      tmp.dir(cb);\n    }\n  }\n\n  getDir(function(err, directory) {\n    if (err) {\n      return callback(err);\n    }\n    const levelupOptions = { valueEncoding: \"json\" };\n    if (self.options.db) {\n      const store = self.options.db;\n      levelup(store, levelupOptions, finishInitializing);\n    } else {\n      self.directory = directory;\n      const store = encode(cachedown(directory, filedown).maxSize(100), levelupOptions);\n      levelup(store, {}, finishInitializing);\n    }\n  });\n\n  function finishInitializing(err, db) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.db = db;\n\n    // Blocks, keyed by array index (not necessarily by block number) (0-based)\n    self.blocks = new LevelUpArrayAdapter(\"blocks\", self.db, blockserializer);\n\n    // Logs triggered in each block, keyed by block id (ids in the blocks array; not necessarily block number) (0-based)\n    self.blockLogs = new LevelUpArrayAdapter(\"blockLogs\", self.db, new BlockLogsSerializer(self));\n\n    // Block hashes -> block ids (ids in the blocks array; not necessarily block number) for quick lookup\n    self.blockHashes = new LevelUpObjectAdapter(\"blockHashes\", self.db);\n\n    // Transaction hash -> transaction objects\n    self.transactions = new LevelUpObjectAdapter(\"transactions\", self.db, txserializer);\n\n    // Transaction hash -> transaction receipts\n    self.transactionReceipts = new LevelUpObjectAdapter(\"transactionReceipts\", self.db, new ReceiptSerializer(self));\n\n    self.trie_db = new LevelUpObjectAdapter(\"trie_db\", self.db, bufferserializer, bufferserializer);\n\n    callback();\n  }\n};\n\nDatabase.prototype.close = function(callback) {\n  callback();\n};\n\nmodule.exports = Database;\n","var Sublevel = require(\"level-sublevel\");\nconst { LevelUpOutOfRangeError, BlockOutOfRangeError } = require(\"../utils/errorhelper\");\n\n// Level up adapter that looks like an array. Doesn't support inserts.\n\nfunction LevelUpArrayAdapter(name, db, serializer) {\n  this.db = Sublevel(db);\n  this.db = this.db.sublevel(name);\n  this.name = name;\n  this.serializer = serializer || {\n    encode: function(val, callback) {\n      callback(null, val);\n    },\n    decode: function(val, callback) {\n      callback(null, val);\n    }\n  };\n}\n\nLevelUpArrayAdapter.prototype.length = function(callback) {\n  this.db.get(\"length\", function(err, result) {\n    if (err) {\n      if (err.notFound) {\n        return callback(null, 0);\n      } else {\n        return callback(err);\n      }\n    }\n\n    callback(null, result);\n  });\n};\n\nLevelUpArrayAdapter.prototype._get = function(key, callback) {\n  var self = this;\n  this.db.get(key, function(err, val) {\n    if (err) {\n      return callback(err);\n    }\n    self.serializer.decode(val, callback);\n  });\n};\n\nLevelUpArrayAdapter.prototype._put = function(key, value, callback) {\n  var self = this;\n  this.serializer.encode(value, function(err, encoded) {\n    if (err) {\n      return callback(err);\n    }\n    self.db.put(key, encoded, callback);\n  });\n};\n\nLevelUpArrayAdapter.prototype.get = function(index, callback) {\n  var self = this;\n\n  this.length(function(err, length) {\n    if (err) {\n      return callback(err);\n    }\n    if (index >= length) {\n      // index out of range\n      let RangeError =\n        self.name === \"blocks\"\n          ? new BlockOutOfRangeError(index, length)\n          : new LevelUpOutOfRangeError(self.name, index, length);\n      return callback(RangeError);\n    }\n    self._get(index, callback);\n  });\n};\n\nLevelUpArrayAdapter.prototype.push = function(val, callback) {\n  var self = this;\n  this.length(function(err, length) {\n    if (err) {\n      return callback(err);\n    }\n\n    // TODO: Do this in atomic batch.\n    self._put(length + \"\", val, function(err) {\n      if (err) {\n        return callback(err);\n      }\n      self.db.put(\"length\", length + 1, callback);\n    });\n  });\n};\n\nLevelUpArrayAdapter.prototype.pop = function(callback) {\n  var self = this;\n\n  this.length(function(err, length) {\n    if (err) {\n      return callback(err);\n    }\n\n    var newLength = length - 1;\n\n    // TODO: Do this in atomic batch.\n    self._get(newLength + \"\", function(err, val) {\n      if (err) {\n        return callback(err);\n      }\n      self.db.del(newLength + \"\", function(err) {\n        if (err) {\n          return callback(err);\n        }\n        self.db.put(\"length\", newLength, function(err) {\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, val);\n        });\n      });\n    });\n  });\n};\n\nLevelUpArrayAdapter.prototype.last = function(callback) {\n  var self = this;\n  this.length(function(err, length) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (length === 0) {\n      return callback(null, null);\n    }\n\n    self._get(length - 1 + \"\", callback);\n  });\n};\n\nLevelUpArrayAdapter.prototype.first = function(callback) {\n  this._get(\"0\", callback);\n};\n\nmodule.exports = LevelUpArrayAdapter;\n","var Sublevel = require(\"level-sublevel\");\nvar async = require(\"async\");\n\nfunction LevelUpObjectAdapter(name, db, valueserializer, keyserializer, options) {\n  this.db = Sublevel(db, options);\n  this.db = this.db.sublevel(name);\n  this.name = name;\n  this.valueserializer = valueserializer || {\n    encode: function(val, callback) {\n      callback(null, val);\n    },\n    decode: function(val, callback) {\n      callback(null, val);\n    }\n  };\n  this.keyserializer = keyserializer || {\n    encode: function(val, callback) {\n      callback(null, val);\n    },\n    decode: function(val, callback) {\n      callback(null, val);\n    }\n  };\n}\n\nLevelUpObjectAdapter.prototype.get = function(key, options, callback) {\n  var self = this;\n\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  this.keyserializer.encode(key, function(err, encodedKey) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.db.get(encodedKey, function(err, val) {\n      if (err) {\n        return callback(err);\n      }\n\n      self.valueserializer.decode(val, function(err, decodedValue) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, decodedValue);\n      });\n    });\n  });\n};\n\nLevelUpObjectAdapter.prototype.put = function(key, value, options, callback) {\n  var self = this;\n\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  this.keyserializer.encode(key, function(err, encodedKey) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.valueserializer.encode(value, function(err, encoded) {\n      if (err) {\n        return callback(err);\n      }\n\n      self.db.put(encodedKey, encoded, callback);\n    });\n  });\n};\n\nLevelUpObjectAdapter.prototype.set = LevelUpObjectAdapter.prototype.put;\n\nLevelUpObjectAdapter.prototype.del = function(key, callback) {\n  var self = this;\n\n  this.keyserializer.encode(key, function(err, encodedKey) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.db.del(encodedKey, callback);\n  });\n};\n\nLevelUpObjectAdapter.prototype.batch = function(array, options, callback) {\n  var self = this;\n\n  async.each(\n    array,\n    function(item, finished) {\n      if (item.type === \"put\") {\n        self.put(item.key, item.value, options, finished);\n      } else if (item.type === \"del\") {\n        self.del(item.key, finished);\n      } else {\n        finished(new Error(\"Unknown batch type\", item.type));\n      }\n    },\n    function(err) {\n      if (err) {\n        return callback(err);\n      }\n      callback();\n    }\n  );\n};\n\nLevelUpObjectAdapter.prototype.isOpen = function() {\n  return true;\n};\n\nmodule.exports = LevelUpObjectAdapter;\n","module.exports = require(\"levelup\");","module.exports = require(\"encoding-down\");","var util = require(\"util\");\nvar AbstractLevelDOWN = require(\"abstract-leveldown\").AbstractLevelDOWN;\nvar async = require(\"async\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\nutil.inherits(FileDown, AbstractLevelDOWN);\n\nfunction FileDown(location) {\n  this.location = location;\n  AbstractLevelDOWN.call(this, location);\n}\n\nFileDown.prototype._open = function(options, callback) {\n  var self = this;\n  callback(null, self);\n};\n\nFileDown.prototype._put = function(key, value, options, callback) {\n  fs.writeFile(path.join(this.location, key), value, \"utf8\", callback);\n};\n\nFileDown.prototype._get = function(key, options, callback) {\n  fs.readFile(path.join(this.location, key), \"utf8\", function(err, data) {\n    if (err) {\n      return callback(new Error(\"NotFound\"));\n    }\n    callback(null, data);\n  });\n};\n\nFileDown.prototype._del = function(key, options, callback) {\n  fs.unlink(path.join(this.location, key), function(err) {\n    // Ignore when we try to delete a file that doesn't exist.\n    // I'm not sure why this happens. Worth looking into.\n    if (err) {\n      if (err.message.indexOf(\"ENOENT\") >= 0) {\n        return callback();\n      } else {\n        return callback(err);\n      }\n    }\n    callback();\n  });\n};\n\nFileDown.prototype._batch = function(array, options, callback) {\n  var self = this;\n  async.each(\n    array,\n    function(item, finished) {\n      if (item.type === \"put\") {\n        self.put(item.key, item.value, options, finished);\n      } else if (item.type === \"del\") {\n        self.del(item.key, options, finished);\n      } else {\n        finished(new Error(\"Unknown batch type\", item.type));\n      }\n    },\n    function(err) {\n      if (err) {\n        return callback(err);\n      }\n      callback();\n    }\n  );\n};\n\nmodule.exports = function(location) {\n  return new FileDown(location);\n};\n","module.exports = require(\"abstract-leveldown\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"cachedown\");","var txserializer = require(\"./txserializer\");\nvar async = require(\"async\");\nvar Block = require(\"ethereumjs-block\");\n\nmodule.exports = {\n  encode: function(block, done) {\n    var encoded = block.toJSON(true);\n\n    async.map(\n      block.transactions,\n      function(tx, finished) {\n        txserializer.encode(tx, finished);\n      },\n      function(err, transactions) {\n        if (err) {\n          return done(err);\n        }\n        encoded.transactions = transactions;\n        done(null, encoded);\n      }\n    );\n  },\n  decode: function(json, done) {\n    var transactions = json.transactions;\n    json.transactions = [];\n\n    var block = new Block(json);\n\n    async.eachSeries(\n      transactions,\n      function(txJson, finished) {\n        txserializer.decode(txJson, function(err, tx) {\n          if (err) {\n            return finished(err);\n          }\n          block.transactions.push(tx);\n          finished();\n        });\n      },\n      function(err) {\n        if (err) {\n          return done(err);\n        }\n\n        done(null, block);\n      }\n    );\n  }\n};\n","var utils = require(\"ethereumjs-util\");\nvar to = require(\"../utils/to\");\n\nmodule.exports = {\n  encode: function(val, cb) {\n    var hex = to.hex(val);\n    cb(null, hex);\n  },\n  decode: function(json, cb) {\n    cb(null, utils.toBuffer(json));\n  }\n};\n","var Log = require(\"../utils/log\");\nvar async = require(\"async\");\n\nfunction BlockLogsSerializer(database) {\n  this.database = database;\n}\n\nBlockLogsSerializer.prototype.encode = function(logs, done) {\n  logs = logs.map(function(log) {\n    return log.toJSON();\n  });\n\n  done(null, logs);\n};\n\nBlockLogsSerializer.prototype.decode = function(json, done) {\n  var self = this;\n\n  if (json.length === 0) {\n    return done(null, []);\n  }\n\n  this.database.blockHashes.get(json[0].blockHash, function(err, blockIndex) {\n    if (err) {\n      return done(err);\n    }\n\n    self.database.blocks.get(blockIndex, function(err, block) {\n      if (err) {\n        return done(err);\n      }\n\n      async.map(\n        json,\n        function(log, finished) {\n          finished(\n            null,\n            new Log({\n              block: block,\n              logIndex: log.logIndex,\n              transactionIndex: log.transactionIndex,\n              transactionHash: log.transactionHash,\n              address: log.address,\n              data: log.data,\n              topics: log.topics,\n              type: log.type\n            })\n          );\n        },\n        function(err, logs) {\n          if (err) {\n            return done(err);\n          }\n          done(null, logs);\n        }\n      );\n    });\n  });\n};\n\nmodule.exports = BlockLogsSerializer;\n","var Receipt = require(\"../utils/receipt\");\nvar async = require(\"async\");\n\nfunction ReceiptSerializer(database) {\n  this.database = database;\n}\n\nReceiptSerializer.prototype.encode = function(receipt, done) {\n  done(null, receipt.toJSON());\n};\n\nReceiptSerializer.prototype.decode = function(json, done) {\n  var self = this;\n  // Make sure we can handle mixed/upper-case transaction hashes\n  // it doesn't seem possible to record a transaction hash that isn't\n  // already lower case, as that's the way ganache generates them, however\n  // I don't think it will hurt anything to normalize here anyway.\n  // If you can figure out how to test this please feel free to add a test!\n  var txHash = json.transactionHash.toLowerCase();\n\n  this.database.transactions.get(json.transactionHash, function(err, tx) {\n    if (err) {\n      return done(err);\n    }\n\n    self.database.blockHashes.get(json.blockHash, function(err, blockIndex) {\n      if (err) {\n        return done(err);\n      }\n\n      async.parallel(\n        {\n          block: self.database.blocks.get.bind(self.database.blocks, blockIndex),\n          logs: self.database.blockLogs.get.bind(self.database.blockLogs, blockIndex)\n        },\n        function(err, result) {\n          if (err) {\n            return done(err);\n          }\n\n          done(\n            null,\n            new Receipt(\n              tx,\n              result.block,\n              result.logs.filter((log) => log.transactionHash.toLowerCase() === txHash),\n              json.gasUsed,\n              json.cumulativeGasUsed,\n              json.contractAddress,\n              json.status,\n              json.logsBloom\n            )\n          );\n        }\n      );\n    });\n  });\n};\n\nmodule.exports = ReceiptSerializer;\n","module.exports = require(\"tmp\");","const BN = require(\"bn.js\");\n\n/**\n * @param {Array} ops Array of all ops/steps of the VM\n * @param {Number} lowestIndex Known lowestIndex\n */\nmodule.exports = (vm, runArgs, err, callback) => {\n  const steps = stepTracker();\n\n  vm.on(\"step\", steps.collect);\n\n  vm.runTx(runArgs, function(vmerr, result) {\n    const opsLength = steps.ops.length;\n    if (vmerr) {\n      // This is a check that has been in there for awhile. I'm unsure if it's required, but it can't hurt.\n      if (vmerr instanceof Error === false) {\n        vmerr = new Error(\"VM error: \" + vmerr);\n      }\n      return callback(vmerr, err);\n    } else if (!steps.success() || !opsLength || opsLength - 1 === steps.lowestGasIndex()) {\n      let estimate = result.gasUsed;\n      if (opsLength) {\n        const lastSVT = steps.lastSVT();\n        if (steps.success() && lastSVT > 0) {\n          const tailCost = steps.ops[lastSVT].gasLeft.sub(steps.ops[steps.ops.length - 1].gasLeft);\n          const stipend = new BN(2300);\n          estimate = estimate.add(new BN(tailCost.lt(stipend) ? stipend.sub(tailCost) : 0));\n        }\n      }\n      result.gasEstimate = estimate;\n    } else {\n      const data = runArgs.tx.data != null ? Array.from(runArgs.tx.data) : [];\n      // Base Fee 21000: cost of an elliptic curve operation to recover the sender pubkey/address from\n      // signature plus disk and bandwidth space of storing the transaction.\n      // Data Costs 4 * (# of 0 bytes) + 68 * (# of non-zero bytes)\n      // This line is just calculating the data costs ^.\n      // Read: start with 21000, iterate through the data\n      // (each element represents a byte)\n      // if the current byte is 0 add 4 otherwise add 68.\n      const costOfData = data.reduce((acc, curr) => acc + (curr === 0 ? 4 : 68), 21000);\n\n      const total = getTotal(0, steps.ops.length - 1, steps.sysOpIndex()) + costOfData;\n      result.gasEstimate = new BN(total);\n    }\n\n    callback(vmerr, result);\n  });\n\n  /**\n   * Returns the sum of all costs in a range\n   * opcode fees, memory expansion costs, return costs, etc\n   * @param {Number} start Beginning index\n   * @param {Number} end Ending index\n   */\n  const sumRange = (start, end) => {\n    const lastSVT = steps.lastSVT();\n    if (lastSVT > start && lastSVT < end) {\n      const top = steps.ops[start].gasLeft - steps.ops[lastSVT].gasLeft;\n      let needed;\n      if (steps.ops[lastSVT].depth) {\n        const tail = steps.ops[lastSVT].gasLeft - steps.ops[end - 1].gasLeft;\n        needed = tail < 2300 ? 2300 - tail : tail;\n      } else {\n        const tail = steps.ops[lastSVT].gasLeft - steps.ops[end].gasLeft;\n        needed = tail < 2300 ? 2300 : tail;\n      }\n      return top + needed;\n    }\n    return steps.ops[start].gasLeft - steps.ops[end].gasLeft;\n  };\n\n  /**\n   * Finds the index in systemOps index\n   * @param {Number} index index of op in steps.ops\n   */\n  const findRootScope = (opIndex) => {\n    const index = steps.findIndex(opIndex);\n    let begin = index;\n    let end = index;\n    const length = steps.systemOps.length;\n    while (begin && steps.systemOps[begin][1]) {\n      --begin;\n    }\n    while (end < length && steps.systemOps[end][1]) {\n      ++end;\n    }\n    return {\n      rootBegin: steps.systemOps[begin][0],\n      rootEnd: steps.systemOps[end - 1][0] + 1 // the op after the matching terminator\n    };\n  };\n\n  /**\n   * Find the range of the current system operation (CREATE, CALL, etc)\n   * @param {Number} index Index of the lowest gas point in the domain\n   */\n  const findParentScope = (opIndex) => {\n    let depth = steps.ops[opIndex].depth;\n    const index = steps.findIndex(opIndex);\n    let begin = index;\n    let end = index;\n    const length = steps.systemOps.length;\n    while (end < length && steps.systemOps[end][1] >= depth) {\n      ++end;\n    }\n    while (begin && steps.systemOps[begin][1] >= depth) {\n      --begin;\n    }\n    return {\n      parentBegin: steps.systemOps[begin][0],\n      parentEnd: steps.systemOps[end - 1][0] + 1 // the op after the matching terminator\n    };\n  };\n\n  /**\n   * Finds the lowest index in a given search space\n   * @param {Number} start The beginning index of the search space\n   * @param {Number} stop The ending index of the search space\n   */\n  const findLowestIndex = (start, stop) => {\n    let lowestGas = Infinity;\n    let lowestIndex = stop;\n    for (let i = start; i <= stop; i++) {\n      if (steps.ops[i].gasLeft <= lowestGas) {\n        // Find the new lowest gas index\n        lowestIndex = i;\n        lowestGas = steps.ops[i].gasLeft;\n      }\n    }\n    return lowestIndex;\n  };\n\n  const gas = (op) => parseInt(`0x${op.gasLeft.toString(\"hex\")}`);\n  const isStipend = (op) => op.gasLeft === 2300;\n\n  /**\n   * Calculates the total gas needed with respect to EIP150\n   * @param {Number} start The beginning index of the search space\n   * @param {Number} stop The ending index of the search space\n   * @param {Number|null} lowestIndex If the index of the lowest gas point is known otherwise null\n   */\n  const getTotal = (start, stop, lowestIndex = null) => {\n    if (lowestIndex) {\n      lowestIndex = steps.systemOps[lowestIndex][0];\n    } else {\n      // If the lowest index is not known ( on recursive calls if the contract is tail heavy )\n      lowestIndex = findLowestIndex(start, stop);\n      if (lowestIndex === stop) {\n        // If the lowest index is the last operation in the range\n        // Return the sum of the range\n        return sumRange(start, stop);\n      }\n    }\n\n    const { rootBegin, rootEnd } = findRootScope(lowestIndex);\n    let { parentBegin, parentEnd } = findParentScope(lowestIndex);\n    let systemOpSum = 0;\n    while (rootBegin !== parentBegin && rootEnd !== parentEnd) {\n      // assert xnor\n      // TODO: Assert op must be a System op: CREATE/CALL/etc\n      const callingSysOp = steps.ops[parentBegin];\n\n      // Cost of the system operation itself\n      const callingFee = callingSysOp.opcode.fee;\n      const sumOfCurrentSysOp = sumRange(parentBegin, parentEnd) - callingFee;\n\n      // What we need before the 1/64 is held back\n      const neededBefore6364 = sumOfCurrentSysOp + Math.floor(sumOfCurrentSysOp / 63);\n      const oneSixtyFloorth = neededBefore6364 - sumOfCurrentSysOp;\n\n      systemOpSum = neededBefore6364 + callingFee;\n      const next = steps.findIndex(lowestIndex) + 1;\n\n      const prevParentBegin = parentBegin;\n      const prevParentEnd = parentEnd;\n\n      ({ parentBegin, parentEnd } = findParentScope(steps.systemOps[next][0]));\n      lowestIndex = parentEnd - 1;\n\n      // Sum to the top of the range above sysOp\n      systemOpSum += gas(steps.ops[parentBegin + 1]) - gas(steps.ops[prevParentBegin]);\n      // systemOpSum += sumRange(parentBegin - 1, prevParentBegin);\n\n      // Sum of the remaining steps after the current (outer) system operation\n      const costOfParentReturn =\n        gas(steps.ops[parentEnd - 1]) -\n        gas(steps.ops[parentEnd]) +\n        gas(steps.ops[parentBegin]) -\n        steps.ops[parentBegin].opcode.fee -\n        gas(steps.ops[parentBegin + 1]);\n      // recursively sum the remaining search space and return this total minus the 1/64th we already accounted for\n      const remaining = getTotal(prevParentEnd, lowestIndex) + costOfParentReturn;\n      // if ((stipend && stipend < remaining) || oneSixtyFloorth < remaining) {\n      let tail = oneSixtyFloorth;\n      if (callingSysOp.opcode.name === \"CALL\" && isStipend(steps.ops[rootBegin + 1])) {\n        tail = 2300;\n      }\n      if (tail < remaining) {\n        systemOpSum = 0;\n      }\n    }\n\n    // TODO: Assert op must be a System op: CREATE/CALL/etc\n    const callingSysOp = steps.ops[rootBegin];\n\n    // Cost of the system operation itself\n    const callingFee = callingSysOp.opcode.fee;\n\n    if (!systemOpSum) {\n      systemOpSum = sumRange(rootBegin, rootEnd) - callingFee;\n    }\n\n    // What we need before the 1/64 is held back\n    const neededBefore6364 = systemOpSum + Math.floor(systemOpSum / 63);\n    let total = neededBefore6364 + callingFee;\n\n    // Sum to the top of the range above sysOp\n    total += sumRange(start, rootBegin);\n\n    const oneSixtyFloorth = neededBefore6364 - systemOpSum;\n    const remaining = getTotal(rootEnd, stop);\n    if (callingSysOp.opcode.name === \"CALL\" && isStipend(steps.ops[rootBegin + 1])) {\n      return total - remaining;\n    }\n\n    // Recursively Sum of the remaining steps after the current (outer) system operation\n    if (oneSixtyFloorth > remaining) {\n      // If we withhold more than the cost of all remaining operations\n      return total;\n    }\n    total -= oneSixtyFloorth;\n\n    return total + remaining;\n  };\n};\n\nconst stepTracker = () => {\n  const sysOps = [];\n  const allOps = [];\n  const svt = [];\n  const isCall = (opname) => [\"CALL\", \"DELEGATECALL\", \"STATICCALL\", \"CALLCODE\"].includes(opname);\n  const isCreate = (opname) => [\"CREATE\"].includes(opname);\n  const isTerminator = (opname) => [\"STOP\", \"RETURN\", \"REVERT\", \"INVALID\", \"SELFDESTRUCT\"].includes(opname);\n  const indexMap = {};\n  let lowestGasLeft = Infinity;\n  let lowestGasIndex = 0;\n  let lowestSysOpIndex;\n  let simpleCallCheck = false;\n  let simpleCallDepth = 0;\n  return {\n    collect: (info) => {\n      const gasLeft = info.gasLeft.toNumber();\n      if (lowestGasLeft > gasLeft) {\n        lowestGasLeft = gasLeft;\n        lowestGasIndex = allOps.length;\n        lowestSysOpIndex = sysOps.length;\n      }\n      // This is checking for what ive been calling a simple value transfer\n      // where there is a CALL operation with no subsequent STOP/RETURN\n      // and where the `call depth` never increases.\n      // It's usually as a result of a .send or .transfer in solidity to an\n      // external account or a contract with no payable\n      if (simpleCallCheck) {\n        // simpleCallCheck acts as a boolean flag checking whether the previous\n        // operation was a CALL. The flag is set during the `isCall` conditional\n        // as well as the simpleCallDepth so its always `up-to-date`.\n        if (info.depth === simpleCallDepth) {\n          // If the current depth (info.depth) equals the depth of a simpleCall\n          // we record its position.  we can probably use a variable rather than an array\n          svt.push(allOps.length);\n        }\n        // Reset the flag immedietely here\n        simpleCallCheck = false;\n      }\n      if (isCall(info.opcode.name)) {\n        simpleCallCheck = true;\n        simpleCallDepth = info.depth;\n        indexMap[allOps.length] = sysOps.length;\n        sysOps.push([allOps.length, info.depth, info.opcode.name]);\n      } else if (isCreate(info.opcode.name) || isTerminator(info.opcode.name)) {\n        indexMap[allOps.length] = sysOps.length;\n        sysOps.push([allOps.length, info.depth, info.opcode.name]);\n      }\n\n      allOps.push(info); // This goes last so we can use the length for the index ^\n    },\n    findIndex: (index) => indexMap[index],\n    lowestGasIndex: () => lowestGasIndex,\n    sysOpIndex: () => lowestSysOpIndex,\n    lastSVT: () => (svt.length ? svt[svt.length - 1] : -1),\n    success: () => !allOps.length || isTerminator(allOps[allOps.length - 1].opcode.name),\n    ops: allOps,\n    systemOps: sysOps,\n    simpleValueTransfers: svt,\n    isTerminator: isTerminator,\n    isCall: isCall\n  };\n};\n","var BlockchainDouble = require(\"../blockchain_double.js\");\nvar Account = require(\"ethereumjs-account\");\nvar Block = require(\"ethereumjs-block\");\nvar Log = require(\"./log.js\");\nvar Receipt = require(\"./receipt.js\");\nvar utils = require(\"ethereumjs-util\");\nvar ForkedStorageTrie = require(\"./forkedstoragetrie.js\");\nvar Web3 = require(\"web3\");\nvar to = require(\"./to.js\");\nvar Transaction = require(\"./transaction\");\nvar async = require(\"async\");\nvar BN = require(\"bn.js\");\n\nvar inherits = require(\"util\").inherits;\n\ninherits(ForkedBlockchain, BlockchainDouble);\n\nfunction ForkedBlockchain(options) {\n  this.options = options || {};\n\n  if (options.fork == null) {\n    throw new Error(\"ForkedBlockchain must be passed a fork parameter.\");\n  }\n\n  this.fork = options.fork;\n  this.forkBlockNumber = options.fork_block_number;\n  this.forkVersion = null;\n\n  if (typeof this.fork === \"string\") {\n    if (this.fork.indexOf(\"@\") >= 0) {\n      var split = this.fork.split(\"@\");\n      this.fork = split[0];\n      this.forkBlockNumber = parseInt(split[1]);\n    }\n\n    this.fork = new Web3.providers.HttpProvider(this.fork);\n  }\n\n  this.time = options.time;\n  this.storageTrieCache = {};\n\n  BlockchainDouble.call(this, options);\n\n  this.createVMFromStateTrie = function() {\n    var vm = BlockchainDouble.prototype.createVMFromStateTrie.apply(this, arguments);\n    this.patchVM(vm);\n    return vm;\n  };\n\n  this.web3 = new Web3(this.fork);\n}\n\nForkedBlockchain.prototype.initialize = function(accounts, callback) {\n  var self = this;\n\n  this.web3.eth.net.getId(function(err, version) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.forkVersion = version;\n\n    BlockchainDouble.prototype.initialize.call(self, accounts, callback);\n  });\n};\nForkedBlockchain.prototype.patchVM = function(vm) {\n  const trie = vm.stateManager._trie;\n  const lookupAccount = this.getLookupAccount(trie);\n  // Unfortunately forking requires a bit of monkey patching, but it gets the job done.\n  vm.stateManager._cache._lookupAccount = lookupAccount;\n  vm.stateManager._lookupStorageTrie = this.getLookupStorageTrie(trie, lookupAccount);\n  vm.stateManager.getContractCode = this.getCode.bind(this);\n};\n\n/**\n * @param db\n * @param root\n * @param options Allows overriding the options passed to the ForkedStorageTrie,\n * like `forkBlockNumber` (required for tracing transactions)\n */\nForkedBlockchain.prototype.createStateTrie = function(db, root, options) {\n  return new ForkedStorageTrie(\n    db,\n    root,\n    Object.assign(\n      {\n        fork: this.fork,\n        forkBlockNumber: this.forkBlockNumber,\n        blockchain: this\n      },\n      options\n    )\n  );\n};\n\nForkedBlockchain.prototype.createGenesisBlock = function(callback) {\n  var self = this;\n  var blockNumber = this.forkBlockNumber || \"latest\";\n\n  self.web3.eth.getBlock(blockNumber, function(err, json) {\n    if (err) {\n      return callback(err);\n    }\n\n    // If no start time was passed, set the time to where we forked from.\n    // We only want to do this if a block was explicitly passed. If a block\n    // number wasn't passed, then we're using the last block and the current time.\n    if (!self.time && self.forkBlockNumber) {\n      self.time = self.options.time = new Date(to.number(json.timestamp) * 1000);\n      self.setTime(self.time);\n    }\n\n    blockNumber = json.number;\n\n    // Update the relevant block numbers\n    self.forkBlockNumber = self.options.fork_block_number = blockNumber;\n    self.stateTrie.forkBlockNumber = self.stateTrie.options.forkBlockNumber = blockNumber;\n\n    self.createBlock(function(err, block) {\n      if (err) {\n        return callback(err);\n      }\n\n      block.header.number = utils.toBuffer(to.number(json.number) + 1);\n      block.header.parentHash = utils.toBuffer(json.hash);\n\n      callback(null, block);\n    });\n  });\n};\n\nForkedBlockchain.prototype.getLookupStorageTrie = function(stateTrie, lookupAccount) {\n  lookupAccount = lookupAccount || this.getLookupAccount(stateTrie);\n  return (address, callback) => {\n    const storageTrie = stateTrie.copy();\n    storageTrie.address = address;\n    lookupAccount(address, (err, account) => {\n      if (err) {\n        return callback(err);\n      }\n\n      storageTrie.root = account.stateRoot;\n      callback(null, storageTrie);\n    });\n  };\n};\n\nForkedBlockchain.prototype.isFallbackBlock = function(value, callback) {\n  var self = this;\n\n  self.getEffectiveBlockNumber(value, function(err, number) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, number <= to.number(self.forkBlockNumber));\n  });\n};\n\nForkedBlockchain.prototype.isBlockHash = function(value) {\n  const isHash = typeof value === \"string\" && value.indexOf(\"0x\") === 0 && value.length > 42;\n  return isHash || (Buffer.isBuffer(value) && value.byteLength > 20);\n};\n\nForkedBlockchain.prototype.isFallbackBlockHash = function(value, callback) {\n  var self = this;\n\n  if (!this.isBlockHash(value)) {\n    return callback(null, false);\n  }\n\n  if (Buffer.isBuffer(value)) {\n    value = to.hex(value);\n  }\n\n  self.data.blockHashes.get(value, function(err, blockIndex) {\n    if (err) {\n      if (err.notFound) {\n        // If the block isn't found in our database, then it must be a fallback block.\n        return callback(null, true);\n      } else {\n        return callback(err);\n      }\n    }\n    callback(null, false);\n  });\n};\n\nForkedBlockchain.prototype.getFallbackBlock = function(numberOrHash, cb) {\n  var self = this;\n\n  if (Buffer.isBuffer(numberOrHash)) {\n    // When tracing a transaction the VM sometimes ask for a block numbers as\n    // buffers instead of numbers.\n    numberOrHash = to.rpcDataHexString(numberOrHash);\n  }\n\n  self.web3.eth.getBlock(numberOrHash, true, function(err, json) {\n    if (err) {\n      return cb(err);\n    }\n\n    if (json == null) {\n      return cb();\n    }\n\n    var block = new Block();\n\n    block.header.parentHash = utils.toBuffer(json.parentHash);\n    block.header.uncleHash = utils.toBuffer(json.sha3Uncles);\n    block.header.coinbase = utils.toBuffer(json.miner);\n    block.header.stateRoot = utils.toBuffer(json.stateRoot); // Should we include the following three?\n    block.header.transactionsTrie = utils.toBuffer(json.transactionsRoot);\n    block.header.receiptTrie = utils.toBuffer(json.receiptsRoot);\n    block.header.bloom = utils.toBuffer(json.logsBloom);\n    block.header.difficulty = utils.toBuffer(\"0x\" + json.totalDifficulty.toString(16)); // BigNumber\n    block.header.number = utils.toBuffer(json.number);\n    block.header.gasLimit = utils.toBuffer(json.gasLimit);\n    block.header.gasUsed = utils.toBuffer(json.gasUsed);\n    block.header.timestamp = utils.toBuffer(json.timestamp);\n    block.header.extraData = utils.toBuffer(json.extraData);\n\n    (json.transactions || []).forEach(function(txJson, index) {\n      block.transactions.push(Transaction.fromJSON(txJson, Transaction.types.real));\n    });\n\n    // Fake block. Let's do the worst.\n    // TODO: Attempt to fill out all block data so as to produce the same hash! (can we?)\n    block.hash = function() {\n      return utils.toBuffer(json.hash);\n    };\n\n    cb(null, block);\n  });\n};\n\nForkedBlockchain.prototype.getBlock = function(number, callback) {\n  let checkFn;\n  const isBlockHash = this.isBlockHash(number);\n  if (isBlockHash) {\n    checkFn = this.isFallbackBlockHash;\n  } else {\n    checkFn = this.isFallbackBlock;\n  }\n  checkFn.call(this, number, (err, isFallback) => {\n    if (err) {\n      return callback(err);\n    }\n    if (isFallback) {\n      return this.getFallbackBlock(number, callback);\n    }\n\n    const getBlock = BlockchainDouble.prototype.getBlock.bind(this);\n    if (isBlockHash) {\n      getBlock(number, callback);\n    } else {\n      this.getRelativeBlockNumber(number, (err, number) => {\n        if (err) {\n          return callback(err);\n        }\n        getBlock(number, callback);\n      });\n    }\n  });\n};\n\nForkedBlockchain.prototype.getStorage = function(address, key, number, callback) {\n  this.getLookupStorageTrie(this.stateTrie)(address, (err, trie) => {\n    if (err) {\n      return callback(err);\n    }\n    this.getEffectiveBlockNumber(number, (err, number) => {\n      if (err) {\n        return callback(err);\n      }\n      trie.get(key, number, callback);\n    });\n  });\n};\n\nForkedBlockchain.prototype.getCode = function(address, number, callback) {\n  var self = this;\n\n  if (typeof number === \"function\") {\n    callback = number;\n    number = \"latest\";\n  }\n\n  if (!number) {\n    number = \"latest\";\n  }\n\n  this.getEffectiveBlockNumber(number, function(err, effective) {\n    if (err) {\n      return callback(err);\n    }\n    number = effective;\n\n    self.stateTrie.keyExists(address, function(err, exists) {\n      if (err) {\n        return callback(err);\n      }\n      // If we've stored the value and we're looking at one of our stored blocks,\n      // get it from our stored data.\n      if (exists && number > to.number(self.forkBlockNumber)) {\n        BlockchainDouble.prototype.getCode.call(self, address, number, callback);\n      } else {\n        // Else, we need to fetch it from web3. If our number is greater than\n        // the fork, let's just use \"latest\".\n        if (number > to.number(self.forkBlockNumber)) {\n          number = \"latest\";\n        }\n\n        self.fetchCodeFromFallback(address, number, function(err, code) {\n          if (code) {\n            code = utils.toBuffer(code);\n          }\n          callback(err, code);\n        });\n      }\n    });\n  });\n};\n\nForkedBlockchain.prototype.getLookupAccount = function(trie) {\n  return (address, callback) => {\n    // If the account doesn't exist in our state trie, get it off the wire.\n    trie.keyExists(address, (err, exists) => {\n      if (err) {\n        return callback(err);\n      }\n      if (exists) {\n        trie.get(address, (err, data) => {\n          if (err) {\n            return callback(err);\n          }\n          const account = new Account(data);\n          callback(null, account);\n        });\n      } else {\n        this.fetchAccountFromFallback(address, to.number(trie.forkBlockNumber), callback);\n      }\n    });\n  };\n};\n\nForkedBlockchain.prototype.getAccount = function(address, number, callback) {\n  var self = this;\n\n  if (typeof number === \"function\") {\n    callback = number;\n    number = \"latest\";\n  }\n\n  this.getEffectiveBlockNumber(number, function(err, effective) {\n    if (err) {\n      return callback(err);\n    }\n    number = effective;\n\n    // If the account doesn't exist in our state trie, get it off the wire.\n    self.stateTrie.keyExists(address, function(err, exists) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (exists && number > to.number(self.forkBlockNumber)) {\n        BlockchainDouble.prototype.getAccount.call(self, address, number, function(err, acc) {\n          if (err) {\n            return callback(err);\n          }\n          callback(null, acc);\n        });\n      } else {\n        self.fetchAccountFromFallback(address, number, callback);\n      }\n    });\n  });\n};\n\nForkedBlockchain.prototype.getTransaction = function(hash, callback) {\n  var self = this;\n  BlockchainDouble.prototype.getTransaction.call(this, hash, function(err, tx) {\n    if (err) {\n      return callback(err);\n    }\n    if (tx != null) {\n      return callback(null, tx);\n    }\n\n    self.web3.eth.getTransaction(hash, function(err, result) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (result) {\n        result = Transaction.fromJSON(result, Transaction.types.signed);\n      }\n\n      callback(null, result);\n    });\n  });\n};\n\nForkedBlockchain.prototype.getTransactionReceipt = function(hash, callback) {\n  var self = this;\n  BlockchainDouble.prototype.getTransactionReceipt.call(this, hash, function(err, receipt) {\n    if (err) {\n      return callback(err);\n    }\n    if (receipt) {\n      return callback(null, receipt);\n    }\n\n    self.web3.eth.getTransactionReceipt(hash, function(err, receiptJson) {\n      if (err) {\n        return callback(err);\n      }\n      if (!receiptJson) {\n        return callback();\n      }\n\n      async.parallel(\n        {\n          tx: self.getTransaction.bind(self, hash),\n          block: self.getBlock.bind(self, receiptJson.blockNumber)\n        },\n        function(err, result) {\n          if (err) {\n            return callback(err);\n          }\n\n          var logs = receiptJson.logs.map(function(log) {\n            return new Log(log);\n          });\n\n          var receipt = new Receipt(\n            result.tx,\n            result.block,\n            logs,\n            receiptJson.gasUsed,\n            receiptJson.cumulativeGasUsed,\n            receiptJson.contractAddress,\n            receiptJson.status,\n            to.hex(receiptJson.logsBloom)\n          );\n\n          callback(null, receipt);\n        }\n      );\n    });\n  });\n};\n\nForkedBlockchain.prototype.fetchAccountFromFallback = function(address, blockNumber, callback) {\n  var self = this;\n  address = to.hex(address);\n\n  async.parallel(\n    {\n      code: this.fetchCodeFromFallback.bind(this, address, blockNumber),\n      balance: this.fetchBalanceFromFallback.bind(this, address, blockNumber),\n      nonce: this.fetchNonceFromFallback.bind(this, address, blockNumber)\n    },\n    function(err, results) {\n      if (err) {\n        return callback(err);\n      }\n\n      var code = results.code;\n      var balance = results.balance;\n      var nonce = results.nonce;\n\n      var account = new Account({\n        nonce: nonce,\n        balance: balance\n      });\n\n      // This puts the code on the trie, keyed by the hash of the code.\n      // It does not actually link an account to code in the trie.\n      account.setCode(self.stateTrie, utils.toBuffer(code), function(err) {\n        if (err) {\n          return callback(err);\n        }\n        callback(null, account);\n      });\n    }\n  );\n};\n\nForkedBlockchain.prototype.fetchCodeFromFallback = function(address, blockNumber, callback) {\n  var self = this;\n  address = to.hex(address);\n\n  // Allow an optional blockNumber\n  if (typeof blockNumber === \"function\") {\n    callback = blockNumber;\n    blockNumber = this.forkBlockNumber;\n  }\n\n  this.getSafeFallbackBlockNumber(blockNumber, function(err, safeBlockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.web3.eth.getCode(address, safeBlockNumber, function(err, code) {\n      if (err) {\n        return callback(err);\n      }\n\n      code = \"0x\" + utils.toBuffer(code).toString(\"hex\");\n      callback(null, code);\n    });\n  });\n};\n\nForkedBlockchain.prototype.fetchBalanceFromFallback = function(address, blockNumber, callback) {\n  var self = this;\n  address = to.hex(address);\n\n  // Allow an optional blockNumber\n  if (typeof blockNumber === \"function\") {\n    callback = blockNumber;\n    blockNumber = this.forkBlockNumber;\n  }\n\n  this.getSafeFallbackBlockNumber(blockNumber, function(err, safeBlockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.web3.eth.getBalance(address, safeBlockNumber, function(err, balance) {\n      if (err) {\n        return callback(err);\n      }\n\n      balance = \"0x\" + new BN(balance).toString(16);\n      callback(null, balance);\n    });\n  });\n};\n\nForkedBlockchain.prototype.fetchNonceFromFallback = function(address, blockNumber, callback) {\n  var self = this;\n  address = to.hex(address);\n\n  // Allow an optional blockNumber\n  if (typeof blockNumber === \"function\") {\n    callback = blockNumber;\n    blockNumber = this.forkBlockNumber;\n  }\n\n  this.getSafeFallbackBlockNumber(blockNumber, function(err, safeBlockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.web3.eth.getTransactionCount(address, safeBlockNumber, function(err, nonce) {\n      if (err) {\n        return callback(err);\n      }\n\n      nonce = \"0x\" + self.web3.utils.toBN(nonce).toString(16);\n      callback(null, nonce);\n    });\n  });\n};\n\nForkedBlockchain.prototype.getHeight = function(callback) {\n  this.latestBlock(function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, to.number(block.header.number));\n  });\n};\n\nForkedBlockchain.prototype.getRelativeBlockNumber = function(number, callback) {\n  var self = this;\n  this.getEffectiveBlockNumber(number, function(err, effective) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, effective - to.number(self.forkBlockNumber) - 1);\n  });\n};\n\nForkedBlockchain.prototype.getSafeFallbackBlockNumber = function(blockNumber, callback) {\n  var forkBlockNumber = to.number(this.forkBlockNumber);\n\n  if (blockNumber == null) {\n    return callback(null, forkBlockNumber);\n  }\n\n  this.getEffectiveBlockNumber(blockNumber, function(err, effective) {\n    if (err) {\n      return callback(err);\n    }\n    if (effective > forkBlockNumber) {\n      effective = forkBlockNumber;\n    }\n\n    callback(null, effective);\n  });\n};\n\nForkedBlockchain.prototype.getBlockLogs = function(number, callback) {\n  var self = this;\n\n  this.getEffectiveBlockNumber(number, function(err, effective) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.getRelativeBlockNumber(effective, function(err, relative) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (relative < 0) {\n        self.getBlock(number, function(err, block) {\n          if (err) {\n            return callback(err);\n          }\n\n          self.web3.currentProvider.send(\n            {\n              jsonrpc: \"2.0\",\n              method: \"eth_getLogs\",\n              params: [\n                {\n                  fromBlock: to.hex(number),\n                  toBlock: to.hex(number)\n                }\n              ],\n              id: new Date().getTime()\n            },\n            function(err, res) {\n              if (err) {\n                return callback(err);\n              }\n\n              var logs = res.result.map(function(log) {\n                // To make this result masquerade as the right information.\n                log.block = block;\n                return new Log(log);\n              });\n\n              callback(null, logs);\n            }\n          );\n        });\n      } else {\n        BlockchainDouble.prototype.getBlockLogs.call(self, relative, callback);\n      }\n    });\n  });\n};\n\nmodule.exports = ForkedBlockchain;\n","const MerklePatriciaTree = require(\"merkle-patricia-tree\");\nconst BaseTrie = require(\"merkle-patricia-tree/baseTrie\");\nconst checkpointInterface = require(\"merkle-patricia-tree/checkpoint-interface\");\nvar utils = require(\"ethereumjs-util\");\nvar inherits = require(\"util\").inherits;\nvar Web3 = require(\"web3\");\nvar to = require(\"./to.js\");\n\ninherits(ForkedStorageBaseTrie, BaseTrie);\n\nfunction ForkedStorageBaseTrie(db, root, options) {\n  BaseTrie.call(this, db, root);\n\n  this.options = options;\n  this.address = options.address;\n  this.forkBlockNumber = options.forkBlockNumber;\n  this.blockchain = options.blockchain;\n  this.fork = options.fork;\n  this.web3 = new Web3(this.fork);\n}\n\n// Note: This overrides a standard method whereas the other methods do not.\nForkedStorageBaseTrie.prototype.get = function(key, blockNumber, callback) {\n  var self = this;\n\n  // Allow an optional blockNumber\n  if (typeof blockNumber === \"function\") {\n    callback = blockNumber;\n    blockNumber = this.forkBlockNumber;\n  }\n\n  key = utils.toBuffer(key);\n\n  // If the account/key doesn't exist in our state trie, get it off the wire.\n  this.keyExists(key, function(err, exists) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (exists) {\n      // TODO: just because we have the key doesn't mean we're at the right\n      // block number/root to send it. We need to check the block number\n      // before using the data in our own trie.\n      MerklePatriciaTree.prototype.get.call(self, key, function(err, r) {\n        callback(err, r);\n      });\n    } else {\n      // If this is the main trie, get the whole account.\n      if (self.address == null) {\n        self.blockchain.fetchAccountFromFallback(key, blockNumber, function(err, account) {\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, account.serialize());\n        });\n      } else {\n        if (to.number(blockNumber) > to.number(self.forkBlockNumber)) {\n          blockNumber = self.forkBlockNumber;\n        }\n        self.web3.eth.getStorageAt(to.rpcDataHexString(self.address), to.rpcDataHexString(key), blockNumber, function(\n          err,\n          value\n        ) {\n          if (err) {\n            return callback(err);\n          }\n\n          value = utils.rlp.encode(value);\n\n          callback(null, value);\n        });\n      }\n    }\n  });\n};\n\nForkedStorageBaseTrie.prototype.keyExists = function(key, callback) {\n  key = utils.toBuffer(key);\n\n  this.findPath(key, function(err, node, remainder, stack) {\n    const exists = node && remainder.length === 0;\n    callback(err, exists);\n  });\n};\n\nForkedStorageBaseTrie.prototype.copy = function() {\n  return new ForkedStorageBaseTrie(this.db, this.root, this.options);\n};\n\ninherits(ForkedStorageTrie, ForkedStorageBaseTrie);\n\nfunction ForkedStorageTrie(db, root, options) {\n  ForkedStorageBaseTrie.call(this, db, root, options);\n  checkpointInterface(this);\n}\n\nForkedStorageTrie.prove = MerklePatriciaTree.prove;\nForkedStorageTrie.verifyProof = MerklePatriciaTree.verifyProof;\n\nmodule.exports = ForkedStorageTrie;\n","module.exports = require(\"merkle-patricia-tree/baseTrie\");","module.exports = require(\"merkle-patricia-tree/checkpoint-interface\");","module.exports = require(\"web3-core\");","module.exports = require(\"web3-eth\");","module.exports = require(\"web3-net\");","module.exports = require(\"web3-eth-personal\");","module.exports = require(\"web3-shh\");","module.exports = require(\"web3-bzz\");","module.exports = require(\"web3-utils\");","module.exports = require(\"eth-sig-util\");","module.exports = {\n  // Mimics crypto.random bytes, but takes in a random number generator\n  // as its second parameter. rng is expected to be a function that takes\n  // no parameters and returns a result like Math.random().\n  // This is important because it allows for a seeded random number generator.\n  // Since this is a mock RPC library, the rng doesn't need to be cryptographically secure.\n  randomBytes: function(length, rng) {\n    var buf = [];\n\n    for (var i = 0; i < length; i++) {\n      buf.push(rng() * 255);\n    }\n\n    return Buffer.from(buf);\n  },\n\n  randomAlphaNumericString: function(length, rng) {\n    const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\n    let text = \"\";\n\n    for (var i = 0; i < length; i++) {\n      text += alphabet.charAt(Math.floor((rng || Math.random)() * alphabet.length));\n    }\n\n    return text;\n  }\n};\n","// this replaces `eth-block-tracker` in the provider-engine, as that block tracker is meant to work with\n// an external provider instance\n\nconst EventEmitter = require(\"events\");\nvar blockHelper = require(\"./utils/block_helper\");\n\nfunction GanacheBlockTracker(opts) {\n  opts = opts || {};\n  EventEmitter.apply(this);\n  if (!opts.blockchain) {\n    throw new Error(\"RpcBlockTracker - no blockchain specified.\");\n  }\n  if (!opts.blockchain.on) {\n    throw new Error(\"RpcBlockTracker - blockchain is not an EventEmitter.\");\n  }\n  this._blockchain = opts.blockchain;\n  this.start = this.start.bind(this);\n  this.stop = this.stop.bind(this);\n  this.getTrackingBlock = this.getTrackingBlock.bind(this);\n  this.awaitCurrentBlock = this.awaitCurrentBlock.bind(this);\n  this._setCurrentBlock = this._setCurrentBlock.bind(this);\n}\n\nGanacheBlockTracker.prototype = Object.create(EventEmitter.prototype);\nGanacheBlockTracker.prototype.constructor = GanacheBlockTracker;\n\nGanacheBlockTracker.prototype.getTrackingBlock = function() {\n  return this._currentBlock;\n};\n\nGanacheBlockTracker.prototype.getCurrentBlock = function() {\n  return this._currentBlock;\n};\n\nGanacheBlockTracker.prototype.awaitCurrentBlock = function() {\n  const self = this;\n  // return if available\n  if (this._currentBlock) {\n    return this._currentBlock;\n  }\n  // wait for \"sync\" event\n  return new Promise((resolve) => this.once(\"block\", resolve)).then(() => self._currentBlock);\n};\n\nGanacheBlockTracker.prototype.start = function(opts = {}) {\n  this._blockchain.on(\"block\", this._setCurrentBlock);\n  return Promise.resolve();\n};\n\nGanacheBlockTracker.prototype.stop = function() {\n  this._isRunning = false;\n  this._blockchain.removeListener(\"block\", this._setCurrentBlock);\n};\n\n//\n// private\n//\n\nGanacheBlockTracker.prototype._setCurrentBlock = function(newBlock) {\n  let block = blockHelper.toJSON(newBlock, true);\n  if (this._currentBlock && this._currentBlock.hash === block.hash) {\n    return;\n  }\n  const oldBlock = this._currentBlock;\n  this._currentBlock = block;\n  this.emit(\"latest\", block);\n  this.emit(\"sync\", { block, oldBlock });\n  this.emit(\"block\", block);\n};\n\nmodule.exports = GanacheBlockTracker;\n","// make sourcemaps work!\nrequire(\"source-map-support/register\");\n\nvar Provider = require(\"./provider\");\nvar webSocketServer = require(\"./webSocketServer\");\nvar httpServer = require(\"./httpServer\");\nvar _ = require(\"lodash\");\n\nmodule.exports = {\n  create: function(options) {\n    options = _applyDefaultOptions(options || {});\n\n    var logger = options.logger;\n    var provider = new Provider(options);\n\n    var server = httpServer(provider, logger);\n    server.keepAliveTimeout = options.keepAliveTimeout;\n\n    let connectionCounter = 0;\n    const connections = {};\n    server.on(\"connection\", (conn) => {\n      let key = connectionCounter++;\n      connections[key] = conn;\n      conn.on(\"close\", () => delete connections[key]);\n    });\n\n    var oldListen = server.listen;\n\n    server.listen = function() {\n      var args = Array.prototype.slice.call(arguments);\n      var callback = function() {};\n      if (args.length > 0) {\n        var last = args[args.length - 1];\n        if (typeof last === \"function\") {\n          callback = args.pop();\n        }\n      }\n\n      var intermediary = function(err) {\n        if (err) {\n          return callback(err);\n        }\n        server.provider.manager.waitForInitialization(callback);\n      };\n\n      args.push(intermediary);\n\n      oldListen.apply(server, args);\n    };\n\n    server.provider = provider;\n\n    if (options.ws) {\n      webSocketServer(server, provider, logger);\n    }\n\n    var oldClose = server.close;\n\n    server.close = function(callback) {\n      var args = Array.prototype.slice.call(arguments);\n      oldClose.apply(server, args);\n\n      server.provider.close(function(err) {\n        if (err) {\n          return callback(err);\n        }\n        Object.keys(connections).forEach((key) => {\n          try {\n            connections[key].destroy();\n          } catch (error) {}\n        });\n      });\n    };\n\n    return server;\n  }\n};\n\nconst defaultOptions = {\n  logger: {\n    log: function() {}\n  },\n  ws: true,\n  keepAliveTimeout: 5000\n};\n\nvar _applyDefaultOptions = function(options) {\n  return _.merge({}, defaultOptions, options);\n};\n","var websocket = require(\"websocket\");\nvar WebSocketServer = websocket.server;\n\nmodule.exports = function(httpServer, provider, logger) {\n  var connectionManager = new ConnectionManager(provider, logger);\n\n  var wsServer = new WebSocketServer({\n    httpServer: httpServer,\n    autoAcceptConnections: true\n  });\n\n  wsServer.on(\"connect\", connectionManager.manageConnection);\n\n  return wsServer;\n};\n\nfunction ConnectionManager(provider, logger) {\n  const self = this;\n  self.provider = provider;\n  self.logger = logger;\n  self.connectionsBySubscriptionId = {};\n  self.connections = {};\n  self.connectionCounter = 0;\n\n  self._updateSubscriptions = self._updateSubscriptions.bind(self);\n  self.manageConnection = self.manageConnection.bind(self);\n  self._logPayload = self._logPayload.bind(self);\n  self._handleRequest = self._handleRequest.bind(self);\n\n  provider.on(\"data\", function(err, notification) {\n    if (err) {\n      return;\n    }\n    self._updateSubscriptions(notification);\n  });\n}\n\nConnectionManager.prototype.manageConnection = function(connection) {\n  const self = this;\n  connection.id = ++self.connectionCounter;\n  self.connections[connection.id] = {\n    connection: connection,\n    subscriptions: {}\n  };\n\n  connection.on(\"message\", function(message) {\n    let payload;\n    try {\n      if (message.type === \"utf8\") {\n        payload = JSON.parse(message.utf8Data);\n      } else if (message.type === \"binary\") {\n        payload = JSON.parse(message.binaryData.toString(\"utf8\").trim());\n      } else {\n        throw new Error(\"Invalid message type\");\n      }\n    } catch (e) {\n      connection.close(websocket.connection.CLOSE_REASON_UNPROCESSABLE_INPUT, e.message);\n      return;\n    }\n\n    self._logPayload(payload);\n    self._handleRequest(connection, payload);\n  });\n\n  connection.on(\"close\", function() {\n    // remove subscriptions\n    Object.keys(self.connections[connection.id].subscriptions).forEach((subscriptionId) => {\n      self.provider.send(\n        {\n          jsonrpc: \"2.0\",\n          method: \"eth_unsubscribe\",\n          params: [subscriptionId],\n          id: new Date().getTime()\n        },\n        function(err, result) {\n          if (err) {\n            return;\n          }\n          delete self.connectionsBySubscriptionId[subscriptionId];\n        }\n      );\n    });\n\n    delete self.connections[connection.id];\n  });\n};\n\nConnectionManager.prototype._handleRequest = function(connection, payload) {\n  const self = this;\n\n  // handle subscription requests, otherwise delegate to provider\n  switch (payload.method) {\n    case \"eth_subscribe\":\n      self.provider.send(payload, function(err, result) {\n        if (!err && result.result && self.connections[connection.id]) {\n          self.connections[connection.id].subscriptions[result.result] = true;\n          self.connectionsBySubscriptionId[result.result] = self.connections[connection.id];\n        }\n        connection.send(JSON.stringify(result));\n      });\n      break;\n    case \"eth_unsubscribe\":\n      self.provider.send(payload, function(err, result) {\n        if (err || result.error) {\n          if (connection && connection.send) {\n            connection.send(JSON.stringify(result));\n          }\n          return;\n        }\n\n        if (self.connections[connection.id]) {\n          delete self.connections[connection.id].subscriptions[payload.params[0]];\n        }\n        delete self.connectionsBySubscriptionId[payload.params[0]];\n\n        connection.send(JSON.stringify(result));\n      });\n      break;\n    default:\n      self.provider.send(payload, function(_, result) {\n        connection.send(JSON.stringify(result));\n      });\n  }\n};\n\n// Log messages that come into the TestRPC via http\nConnectionManager.prototype._logPayload = function(payload) {\n  const self = this;\n  if (payload instanceof Array) {\n    // Batch request\n    for (var i = 0; i < payload.length; i++) {\n      var item = payload[i];\n      self.logger.log(item.method);\n    }\n  } else {\n    self.logger.log(payload.method);\n  }\n};\n\nConnectionManager.prototype._updateSubscriptions = function(notification) {\n  const subscription = this.connectionsBySubscriptionId[notification.params.subscription];\n  // Safety check for subscription/connection.\n  if (subscription) {\n    subscription.connection.send(JSON.stringify(notification));\n  }\n};\n","module.exports = require(\"websocket\");","const http = require(\"http\");\nconst { rpcError } = require(\"./utils/to\");\n\nfunction createCORSResponseHeaders(method, requestHeaders) {\n  // https://fetch.spec.whatwg.org/#http-requests\n  const headers = {};\n  let isCORSRequest = requestHeaders.hasOwnProperty(\"origin\");\n  if (isCORSRequest) {\n    // OPTIONS preflight requests need a little extra treatment\n    if (method === \"OPTIONS\") {\n      // we only allow POST requests, so it doesn't matter which method the request is asking for\n      headers[\"Access-Control-Allow-Methods\"] = \"POST\";\n      // echo all requested access-control-request-headers back to the response\n      if (requestHeaders.hasOwnProperty(\"access-control-request-headers\")) {\n        headers[\"Access-Control-Allow-Headers\"] = requestHeaders[\"access-control-request-headers\"];\n      }\n      // Safari needs Content-Length = 0 for a 204 response otherwise it hangs forever\n      // https://github.com/expressjs/cors/pull/121#issue-130260174\n      headers[\"Content-Length\"] = 0;\n\n      // Make browsers and compliant clients cache the OPTIONS preflight response for 10\n      // minutes (this is the maximum time Chromium allows)\n      headers[\"Access-Control-Max-Age\"] = 600; // seconds\n    }\n\n    // From the spec: https://fetch.spec.whatwg.org/#http-responses\n    // \"For a CORS-preflight request, requests credentials mode is always \"omit\",\n    // but for any subsequent CORS requests it might not be. Support therefore\n    // needs to be indicated as part of the HTTP response to the CORS-preflight request as well.\", so this\n    // header is added to all requests.\n    // Additionally, https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials,\n    // states that there aren't any HTTP Request headers that indicate you whether or not Request.withCredentials\n    // is set. Because web3@1.0.0-beta.35-? always sets `request.withCredentials = true` while Safari requires it be\n    // returned even when no credentials are set in the browser this header must always be return on all requests.\n    // (I've found that Chrome and Firefox don't actually require the header when credentials aren't set)\n    //  Regression Commit: https://github.com/ethereum/web3.js/pull/1722\n    //  Open Web3 Issue: https://github.com/ethereum/web3.js/issues/1802\n    headers[\"Access-Control-Allow-Credentials\"] = true;\n\n    // From the spec: \"It cannot be reliably identified as participating in the CORS protocol\n    // as the `Origin` header is also included for all requests whose method is neither\n    // `GET` nor `HEAD`.\"\n    // Explicitly set the origin instead of using *, since credentials\n    // can't be used in conjunction with *. This will always be set\n    /// for valid preflight requests.\n    headers[\"Access-Control-Allow-Origin\"] = requestHeaders.origin;\n  }\n  return headers;\n}\n\nfunction sendResponse(response, statusCode, headers, data) {\n  response.writeHead(statusCode, headers);\n  response.end(data);\n}\n\nmodule.exports = function(provider, logger) {\n  var server = http.createServer(function(request, response) {\n    var method = request.method;\n    var body = [];\n\n    request\n      .on(\"data\", function(chunk) {\n        body.push(chunk);\n      })\n      .on(\"end\", function() {\n        body = Buffer.concat(body).toString();\n        // At this point, we have the headers, method, url and body, and can now\n        // do whatever we need to in order to respond to this request.\n\n        const headers = createCORSResponseHeaders(method, request.headers);\n\n        switch (method) {\n          case \"POST\":\n            var payload;\n            try {\n              payload = JSON.parse(body);\n            } catch (e) {\n              headers[\"Content-Type\"] = \"text/plain\";\n              sendResponse(response, 400, headers, \"400 Bad Request\");\n              return;\n            }\n\n            // Log messages that come into the TestRPC via http\n            if (payload instanceof Array) {\n              // Batch request\n              for (var i = 0; i < payload.length; i++) {\n                var item = payload[i];\n                logger.log(item.method);\n              }\n            } else {\n              logger.log(payload.method);\n            }\n\n            // http connections do not support subscriptions\n            if (payload.method === \"eth_subscribe\" || payload.method === \"eth_unsubscribe\") {\n              headers[\"Content-Type\"] = \"application/json\";\n              sendResponse(response, 400, headers, rpcError(payload.id, -32000, \"notifications not supported\"));\n              break;\n            }\n\n            provider.send(payload, function(_, result) {\n              headers[\"Content-Type\"] = \"application/json\";\n              sendResponse(response, 200, headers, JSON.stringify(result));\n            });\n\n            break;\n          case \"OPTIONS\":\n            sendResponse(response, 204, headers);\n            break;\n          default:\n            headers[\"Content-Type\"] = \"text/plain\";\n            sendResponse(response, 400, headers, \"400 Bad Request\");\n            break;\n        }\n      });\n  });\n\n  server.ganacheProvider = provider;\n  return server;\n};\n","module.exports = require(\"http\");"],"sourceRoot":""}